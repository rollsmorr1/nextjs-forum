This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-19T17:56:58.050Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    commands.yml
.husky/
  pre-commit
apps/
  bot/
    commands/
      context/
        index.ts
        mark-answer.ts
      slash/
        add-regular-member-role.ts
        get-answer-count.ts
        index.ts
        lock-low-effort-post.ts
        lock-post.ts
        refresh-answer-count.ts
        refresh-last-active.ts
        remove-post-answer.ts
        revoke-regular-member-role.ts
      types.ts
    db/
      actions/
        channels.ts
        messages.ts
        posts.ts
        users.ts
    lib/
      cache.ts
      points.ts
    env.ts
    index.ts
    log.ts
    package.json
    register-commands.ts
    revalidate.ts
    tsconfig.json
    utils.ts
  web/
    .vscode/
      settings.json
    app/
      (home)/
        page/
          [page]/
            page.tsx
        layout.tsx
        page.tsx
      post/
        [id]/
          page.tsx
      user/
        [discordID]/
          page.tsx
      discord-markdown.css
      globals.css
      layout.tsx
      robots.ts
      sitemap.ts
    components/
      icons/
        arrow-down.tsx
        arrow-left.tsx
        arrow-right.tsx
        base.tsx
        calender-plus.tsx
        check-circle-solid.tsx
        discord.tsx
        github.tsx
        heart.tsx
        inbox.tsx
        incognito.tsx
        medal.tsx
        next.tsx
        shield-check.tsx
      layout-with-sidebar.tsx
      local-time.tsx
      message-content.tsx
      message-group.tsx
      message.tsx
      most-helpful.tsx
      pagination-link.tsx
      post.tsx
      posts-list.tsx
      sidebar.tsx
    pages/
      api/
        revalidate-home.ts
        revalidate-post.ts
    utils/
      datetime.ts
      discord-markdown.ts
      group-messages.ts
      luxon.ts
      truncate.ts
      urls.ts
      video.ts
    .eslintrc.js
    next-env.d.ts
    next.config.js
    package.json
    postcss.config.js
    tailwind.config.js
    tsconfig.json
packages/
  db/
    migrations/
      0-initial.ts
      1-add-moderator.ts
      2-users-answer-count.ts
      3-add-last-active-to-post.ts
      4-points-system.ts
      5-posts-is-indexed-flag.ts
      6-create-profile-page.ts
    .eslintrc.cjs
    load-env.ts
    migrate.ts
    migrations-utils.ts
    node.ts
    package.json
    schema.ts
    tsconfig.json
  eslint-config-custom/
    index.js
    package.json
  tsconfig/
    base.json
    nextjs.json
    node.json
    package.json
    react-library.json
.eslintrc.js
.gitignore
.prettierrc
docker-compose.yml
LICENSE
package.json
pnpm-workspace.yaml
README.md
turbo.json

================================================================
Repository Files
================================================================

================
File: .github/workflows/commands.yml
================
name: Deploy Discord Commands

on:
  push:
    branches:
      - main

jobs:
  deploy-commands:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Corepack
        run: corepack enable pnpm

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build bot
        run: pnpm build:bot

      - name: Deploy Commands
        run: pnpm register-commands
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          INDEXABLE_CHANNEL_IDS: ''
          REVALIDATE_SECRET: ''
          WEB_URL: ''

================
File: .husky/pre-commit
================
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged

================
File: apps/bot/commands/context/index.ts
================
import * as markAnswer from './mark-answer.js'

export const contextMenuCommands = [markAnswer.command]

================
File: apps/bot/commands/context/mark-answer.ts
================
import {
  ApplicationCommandType,
  ButtonStyle,
  ChannelType,
  Colors,
  ComponentType,
  ContextMenuCommandBuilder,
  PermissionFlagsBits,
} from 'discord.js'
import { ContextMenuCommand } from '../types.js'
import {
  isMessageInForumChannel,
  isMessageSupported,
  replyWithEmbed,
  replyWithEmbedError,
} from '../../utils.js'
import { markMessageAsSolution } from '../../db/actions/messages.js'
import { env } from '../../env.js'
import { tryToSetRegularMemberRole } from '../../lib/points.js'

export const command: ContextMenuCommand = {
  data: new ContextMenuCommandBuilder()
    .setName('Mark Solution')
    .setDMPermission(false)
    .setDefaultMemberPermissions(PermissionFlagsBits.SendMessages)
    .setType(ApplicationCommandType.Message),

  async execute(interaction) {
    if (!interaction.channel || !isMessageInForumChannel(interaction.channel)) {
      await replyWithEmbedError(interaction, {
        description:
          'This command can only be used in a supported forum channel',
      })

      return
    }

    if (!isMessageSupported(interaction.targetMessage)) {
      await replyWithEmbedError(interaction, {
        description:
          "This type of message is not supported. Make sure the author isn't a bot and the post is indexed",
      })

      return
    }

    const mainChannel = interaction.channel.parent
    if (!mainChannel) {
      await replyWithEmbedError(interaction, {
        description:
          'Could not find the parent channel, please try again later. If this issue persists, contact a staff member',
      })

      return
    }

    if (mainChannel.type !== ChannelType.GuildForum) {
      await interaction.reply({
        ephemeral: true,
        content: 'The parent channel is not a forum channel',
      })

      return
    }

    const interactionMember = await interaction.guild?.members.fetch(
      interaction.user,
    )
    if (!interactionMember) {
      await replyWithEmbedError(interaction, {
        description:
          'Could not find your info in the server, please try again later. If this issue persists, contact a staff member',
      })

      return
    }

    if (
      interaction.channel.ownerId !== interaction.user.id &&
      !interactionMember.permissions.has(PermissionFlagsBits.ManageMessages) &&
      (env.HELPER_ROLE_ID
        ? !interactionMember.roles.cache.has(env.HELPER_ROLE_ID)
        : true)
    ) {
      await replyWithEmbedError(interaction, {
        description:
          'Only the post author, helpers or moderators can mark a message as the answer',
      })

      return
    }

    if (interaction.targetId === interaction.channelId) {
      await replyWithEmbedError(interaction, {
        description:
          "You can't mark the post itself as the answer. If you figured out the issue by yourself, please send it as a separate message and mark it as the answer",
      })

      return
    }

    await markMessageAsSolution(
      interaction.targetMessage.id,
      interaction.channelId,
    )

    const targetMember = await interaction.guild?.members.fetch(
      interaction.targetMessage.author.id,
    )
    if (targetMember) {
      await tryToSetRegularMemberRole(interactionMember)
    }

    const answeredTagId = mainChannel.availableTags.find((t) =>
      t.name.includes('Answered'),
    )?.id

    if (answeredTagId) {
      const newTags = Array.from(
        new Set([...interaction.channel.appliedTags, answeredTagId]),
      )
      interaction.channel.setAppliedTags(newTags)
    }

    await replyWithEmbed(interaction, {
      title: '‚úÖ Success!',
      description:
        'This question has been marked as answered! If you have any other questions, feel free to create another post',
      color: Colors.Green,
      fields: [
        {
          name: 'Jump to answer',
          value: `[Click here](${interaction.targetMessage.url})`,
          inline: true,
        },
      ],
    })
    await interaction.targetMessage.react('‚úÖ')

    // edit instructions message to add the button for message url (get the first message sent by the bot)
    const instructionsMessage = (
      await interaction.channel.messages.fetch({
        cache: true,
        after: interaction.channel.id,
      })
    )
      .filter((m) => m.author.id === interaction.client.user?.id)
      .last()

    if (instructionsMessage) {
      try {
        instructionsMessage.edit({
          components: [
            {
              type: ComponentType.ActionRow,
              components: [
                {
                  type: ComponentType.Button,
                  style: ButtonStyle.Link,
                  label: 'Jump to Answer',
                  url: interaction.targetMessage.url,
                },
              ],
            },
          ],
        })
      } catch (err) {
        console.error('Failed to update instructions message:', err)
      }
    }

    // if the message author is the post creator, notify mods to ensure its a genuine solution
    if (interaction.targetMessage.author.id === interaction.channel.ownerId) {
      if (env.MOD_LOG_CHANNEL_ID) {
        const modLogChannel = interaction.client.channels.cache.get(
          env.MOD_LOG_CHANNEL_ID,
        )
        if (!modLogChannel?.isTextBased()) return

        await modLogChannel.send({
          content: `OP self marked their message: ${interaction.targetMessage.url}`,
        })
      }
    }
  },
}

================
File: apps/bot/commands/slash/add-regular-member-role.ts
================
import { PermissionFlagsBits, SlashCommandBuilder } from 'discord.js'
import { SlashCommand } from '../types.js'
import { addFullPointsToUser, syncUser } from '../../db/actions/users.js'
import { tryToSetRegularMemberRole } from '../../lib/points.js'

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('add-regular-member-role')
    .setDescription('Add the Regular Member role to the target user')
    .setDMPermission(false)
    .addUserOption((option) =>
      option
        .setName('user')
        .setDescription('The user to receive the role')
        .setRequired(true),
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.ModerateMembers),

  async execute(interaction) {
    const user = interaction.options.getUser('user', true)

    const guildMember = await interaction.guild?.members.fetch(user.id)

    if (!guildMember) {
      await interaction.reply({
        content: "I couldn't find the guild member from this user",
        ephemeral: true,
      })
      return
    }

    await interaction.deferReply({ ephemeral: true })

    await syncUser(user, guildMember)
    await addFullPointsToUser(user.id)
    await tryToSetRegularMemberRole(guildMember, true)

    await interaction.editReply({ content: 'Done!' })
  },
}

================
File: apps/bot/commands/slash/get-answer-count.ts
================
import { SlashCommandBuilder } from 'discord.js'
import { SlashCommand } from '../types.js'
import { getCorrectAnswersCount } from '../../db/actions/users.js'

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('get-answer-count')
    .setDescription('Get the number of your accepted answers')
    .addUserOption((user) =>
      user
        .setName('user')
        .setDescription('The user to get number of marked answers for')
        .setRequired(false),
    )
    .setDMPermission(false),

  async execute(interaction) {
    await interaction.deferReply({ ephemeral: true })
    // Get the user option
    const userOption = interaction.options.getUser('user')

    // Use the ID of the user option if it's provided, otherwise use the ID of the interaction user
    const userId = userOption?.id || interaction.user.id
    const userArgProvided = !!userOption
    const count = await getCorrectAnswersCount(userId)

    // Also executes if count is 0
    if (!count) {
      await interaction.editReply({
        content: `It looks like ${
          userArgProvided
            ? 'this user is new to the forum!'
            : "you are new to the forum. Start by answering some questions and you'll see your progress here!"
        }`,
      })
      return
    }

    const guildMember = await interaction.guild?.members.fetch(userId)

    if (!guildMember) {
      await interaction.editReply({
        content: `The user is not in this server.`,
      })
      return
    }

    await interaction.editReply({
      content: `${
        userArgProvided ? `${guildMember.user.username} has` : 'You have'
      } ${count.answersCount} correct ${
        count.answersCount === 1 ? 'answer' : 'answers'
      }!`,
    })
  },
}

================
File: apps/bot/commands/slash/index.ts
================
import * as refreshAnswerCount from './refresh-answer-count.js'
import * as refreshLastActive from './refresh-last-active.js'
import * as lockLowEffortPost from './lock-low-effort-post.js'
import * as removePostAnswer from './remove-post-answer.js'
import * as addRegularMemberRole from './add-regular-member-role.js'
import * as revokeRegularMemberRole from './revoke-regular-member-role.js'
import * as getAnswerCount from './get-answer-count.js'

export const slashCommands = [
  refreshAnswerCount.command,
  refreshLastActive.command,
  lockLowEffortPost.command,
  removePostAnswer.command,
  addRegularMemberRole.command,
  revokeRegularMemberRole.command,
  getAnswerCount.command,
]

================
File: apps/bot/commands/slash/lock-low-effort-post.ts
================
import {
  ChannelType,
  Colors,
  PermissionFlagsBits,
  SlashCommandBuilder,
} from 'discord.js'
import { dedent } from 'ts-dedent'
import { SlashCommand } from '../types.js'
import { replyWithEmbedError } from '../../utils.js'
import { unindexPost } from '../../db/actions/posts.js'

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('lock-low-effort-post')
    .setDescription('Locks a post and sends a message explaining the reason')
    .setDMPermission(false)
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageThreads),

  async execute(interaction) {
    if (!interaction.channel?.isThread()) {
      await replyWithEmbedError(interaction, {
        description: 'This command can only be used in a thread/forum post',
      })
      return
    }

    const mainChannel = interaction.channel.parent
    if (mainChannel && mainChannel.type === ChannelType.GuildForum) {
      const lockedTagId = mainChannel.availableTags.find((t) =>
        t.name.includes('Locked'),
      )?.id

      if (lockedTagId) {
        const newTags = Array.from(
          new Set([...interaction.channel.appliedTags, lockedTagId]),
        )
        interaction.channel.setAppliedTags(newTags)
      }
    }

    interaction.reply({ content: 'Ok!', ephemeral: true })

    await interaction.channel.setLocked(true)
    await interaction.channel.send({
      embeds: [
        {
          color: Colors.Blue,
          title: 'üîí Post Locked',
          description: dedent`
            This post has been locked because it was considered low-effort by the moderation team. We encourage you to create a new post, keeping in mind the guidelines described here: https://discord.com/channels/752553802359505017/1138338531983491154

            Try to add as much information possible in your question, describing your objective and what you have tried doing to solve it. This helps our members to understand better the question and give a better and faster answer. If you have any questions, feel free to reach out to the moderation team.
          `,
        },
      ],
    })

    await unindexPost(interaction.channel)
  },
}

================
File: apps/bot/commands/slash/lock-post.ts
================
import {
  ChannelType,
  Colors,
  PermissionFlagsBits,
  SlashCommandBuilder,
} from 'discord.js'
import { SlashCommand } from '../types.js'
import { replyWithEmbedError } from '../../utils.js'
import { unindexPost } from '../../db/actions/posts.js'

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('lock-post')
    .setDescription('Locks a post and sends a message explaining the reason')
    .setDMPermission(false)
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageThreads),

  async execute(interaction) {
    if (!interaction.channel?.isThread()) {
      await replyWithEmbedError(interaction, {
        description: 'This command can only be used in a thread/forum post',
      })
      return
    }

    const mainChannel = interaction.channel.parent
    if (mainChannel && mainChannel.type === ChannelType.GuildForum) {
      const lockedTagId = mainChannel.availableTags.find((t) =>
        t.name.includes('Locked'),
      )?.id

      if (lockedTagId) {
        const newTags = Array.from(
          new Set([...interaction.channel.appliedTags, lockedTagId]),
        )
        interaction.channel.setAppliedTags(newTags)
      }
    }

    interaction.reply({ content: 'Ok!', ephemeral: true })

    await interaction.channel.setLocked(true)
    await interaction.channel.send({
      embeds: [
        {
          color: Colors.Blue,
          title: 'üîí Post Locked',
          description:
            'This post has been locked by a moderator. If you have any questions, feel free to reach out to the moderation team.',
        },
      ],
    })

    await unindexPost(interaction.channel)
  },
}

================
File: apps/bot/commands/slash/refresh-answer-count.ts
================
import { Colors, PermissionFlagsBits, SlashCommandBuilder } from 'discord.js'
import { SlashCommand } from '../types.js'
import { replyWithEmbed } from '../../utils.js'
import { db } from '@nextjs-forum/db/node'

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('refresh-answer-count')
    .setDescription(
      'Refreshes the count of answers for every user (expensive call so only use it if really necessary)',
    )
    .setDMPermission(false)
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  async execute(interaction) {
    await replyWithEmbed(interaction, {
      title: '‚åõ Processing...',
      description:
        'Your request has been queued. This might take a while to complete...',
    })

    try {
      await db
        .updateTable('users')
        .set({
          answersCount: (eb) =>
            eb
              .selectFrom('posts')
              .select(eb.fn.countAll<number>().as('count'))
              .innerJoin('messages', (join) =>
                join
                  .onRef('messages.snowflakeId', '=', 'posts.answerId')
                  .onRef('messages.userId', '=', 'users.snowflakeId'),
              ),
        })
        .execute()

      await interaction.editReply({
        embeds: [
          {
            title: '‚úÖ Success!',
            description: 'The answer count of the users has been updated',
            color: Colors.Green,
          },
        ],
      })
    } catch (err) {
      const description = err instanceof Error ? err.message : 'Unknown reason'

      await interaction.editReply({
        embeds: [
          {
            title: 'Error',
            description,
          },
        ],
      })
    }
  },
}

================
File: apps/bot/commands/slash/refresh-last-active.ts
================
import { Colors, PermissionFlagsBits, SlashCommandBuilder } from 'discord.js'
import { SlashCommand } from '../types.js'
import { replyWithEmbed } from '../../utils.js'
import { db, sql } from '@nextjs-forum/db/node'
import { baseLog } from '../../log.js'

const log = baseLog.extend('refresh-last-active')

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('refresh-last-active')
    .setDescription(
      'Refreshes the last active time for every post (expensive call so only use it if really necessary)',
    )
    .setDMPermission(false)
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  async execute(interaction) {
    await replyWithEmbed(interaction, {
      title: '‚åõ Processing...',
      description:
        'Your request has been queued. This might take a while to complete...',
    })

    try {
      log('Loading all posts with dates...')

      // update posts with lastmod time
      const posts = await db
        .selectFrom('posts')
        .select([
          'posts.snowflakeId',
          sql<Date>`MAX(IFNULL(posts.editedAt, posts.createdAt))`.as(
            'lastModTime',
          ),
          sql<Date>`MAX(IFNULL(messages.editedAt, messages.createdAt))`.as(
            'lastMessageModTime',
          ),
        ])
        .leftJoin('messages', 'posts.snowflakeId', 'messages.postId')
        .groupBy('posts.snowflakeId')
        .execute()

      log('Loaded %d posts, starting transaction chunks', posts.length)

      const chunkSize = 100
      for (let i = 0; i < posts.length; i += chunkSize) {
        const chunk = posts.slice(i, i + chunkSize)

        log('Executing transaction chunk %d', i / chunkSize)

        await db.transaction().execute(async (trx) => {
          for (const post of chunk) {
            const lastActive =
              post.lastMessageModTime > post.lastModTime
                ? post.lastMessageModTime
                : post.lastModTime

            await trx
              .updateTable('posts')
              .where('posts.snowflakeId', '=', post.snowflakeId)
              .set({ lastActiveAt: lastActive })
              .execute()
          }
        })

        await new Promise((resolve) => setTimeout(resolve, 100))
      }

      log('Transaction completed')

      await interaction.editReply({
        embeds: [
          {
            title: '‚úÖ Success!',
            description: 'The answer count of the users has been updated',
            color: Colors.Green,
          },
        ],
      })
    } catch (err) {
      const description = err instanceof Error ? err.message : 'Unknown reason'

      await interaction.editReply({
        embeds: [
          {
            title: 'Error',
            description,
          },
        ],
      })
    }
  },
}

================
File: apps/bot/commands/slash/remove-post-answer.ts
================
import {
  ChannelType,
  Colors,
  PermissionFlagsBits,
  SlashCommandBuilder,
} from 'discord.js'
import { SlashCommand } from '../types.js'
import {
  isMessageInForumChannel,
  replyWithEmbed,
  replyWithEmbedError,
} from '../../utils.js'
import { env } from '../../env.js'
import { markMessageAsSolution } from '../../db/actions/messages.js'

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('remove-post-answer')
    .setDescription('Removes the answer from a post')
    .setDMPermission(false)
    .setDefaultMemberPermissions(PermissionFlagsBits.SendMessages),

  async execute(interaction) {
    if (!interaction.channel || !isMessageInForumChannel(interaction.channel)) {
      await replyWithEmbedError(interaction, {
        description:
          'This command can only be used in a supported forum channel',
      })

      return
    }

    const mainChannel = interaction.channel.parent
    if (!mainChannel) {
      await replyWithEmbedError(interaction, {
        description:
          'Could not find the parent channel, please try again later. If this issue persists, contact a staff member',
      })

      return
    }

    if (mainChannel.type !== ChannelType.GuildForum) {
      await interaction.reply({
        ephemeral: true,
        content: 'The parent channel is not a forum channel',
      })

      return
    }

    const interactionMember = await interaction.guild?.members.fetch(
      interaction.user,
    )
    if (!interactionMember) {
      await replyWithEmbedError(interaction, {
        description:
          'Could not find your info in the server, please try again later. If this issue persists, contact a staff member',
      })

      return
    }

    if (
      interaction.channel.ownerId !== interaction.user.id &&
      !interactionMember.permissions.has(PermissionFlagsBits.ManageMessages) &&
      (env.HELPER_ROLE_ID
        ? !interactionMember.roles.cache.has(env.HELPER_ROLE_ID)
        : true)
    ) {
      await replyWithEmbedError(interaction, {
        description:
          'Only the post author, helpers or moderators can remove an answer from apost',
      })

      return
    }

    await markMessageAsSolution(null, interaction.channelId)

    const answeredTagId = mainChannel.availableTags.find((t) =>
      t.name.includes('Answered'),
    )?.id

    if (answeredTagId) {
      const newTags = interaction.channel.appliedTags.filter(
        (tag) => tag !== answeredTagId,
      )
      interaction.channel.setAppliedTags(newTags)
    }

    await replyWithEmbed(interaction, {
      title: '‚úÖ Success!',
      description: "This question's answer has been removed.",
      color: Colors.Orange,
    })

    // edit instructions message to remove the button for message url (get the first message sent by the bot)
    const instructionsMessage = (
      await interaction.channel.messages.fetch({
        cache: true,
        after: interaction.channel.id,
      })
    )
      .filter((m) => m.author.id === interaction.client.user?.id)
      .last()

    if (instructionsMessage) {
      try {
        instructionsMessage.edit({
          components: [],
        })
      } catch (err) {
        console.error('Failed to update instructions message:', err)
      }
    }
  },
}

================
File: apps/bot/commands/slash/revoke-regular-member-role.ts
================
import { PermissionFlagsBits, SlashCommandBuilder } from 'discord.js'
import { SlashCommand } from '../types.js'
import { removeFullPointsFromUser, syncUser } from '../../db/actions/users.js'
import { tryToSetRegularMemberRole } from '../../lib/points.js'

export const command: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('revoke-regular-member-role')
    .setDescription('Remove the Regular Member role from the target user')
    .setDMPermission(false)
    .addUserOption((option) =>
      option
        .setName('user')
        .setDescription('The user to be stripped of the role')
        .setRequired(true),
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.ModerateMembers),

  async execute(interaction) {
    const user = interaction.options.getUser('user', true)

    const guildMember = await interaction.guild?.members.fetch(user.id)

    if (!guildMember) {
      await interaction.reply({
        content: "I couldn't find the guild member from this user",
        ephemeral: true,
      })
      return
    }

    await interaction.deferReply({ ephemeral: true })

    await syncUser(user, guildMember)
    await removeFullPointsFromUser(user.id)
    await tryToSetRegularMemberRole(guildMember, true)

    await interaction.editReply({ content: 'Done!' })
  },
}

================
File: apps/bot/commands/types.ts
================
import {
  ChatInputCommandInteraction,
  ContextMenuCommandBuilder,
  MessageContextMenuCommandInteraction,
  SlashCommandBuilder,
} from 'discord.js'

export type ContextMenuCommand = {
  data: ContextMenuCommandBuilder
  execute: (
    interaction: MessageContextMenuCommandInteraction,
  ) => void | Promise<void>
}

export type SlashCommand = {
  data: SlashCommandBuilder
  execute: (interaction: ChatInputCommandInteraction) => void | Promise<void>
}

================
File: apps/bot/db/actions/channels.ts
================
import { db } from '@nextjs-forum/db/node'
import { channelsCache } from '../../lib/cache.js'
import { Channel, ChannelType } from 'discord.js'
import { baseLog } from '../../log.js'
import { isMessageInForumChannel } from '../../utils.js'

const log = baseLog.extend('channels')

export const syncMessageChannel = async (messageChannel: Channel) => {
  if (!isMessageInForumChannel(messageChannel) || !messageChannel.parent) return
  const mainChannel = messageChannel.parent

  if (
    mainChannel.type !== ChannelType.GuildForum &&
    mainChannel.type !== ChannelType.GuildText
  ) {
    return
  }

  await syncChannel(mainChannel)
}

export const syncChannel = async (channel: Channel) => {
  const isCached = channelsCache.get(channel.id)
  if (isCached) return

  const isGuildBasedChannel = 'guild' in channel
  if (!isGuildBasedChannel) return

  const topic = 'topic' in channel ? channel.topic : null

  await db
    .insertInto('channels')
    .values({
      snowflakeId: channel.id,
      name: channel.name,
      type: channel.type,
      topic: topic ?? '',
    })
    .onConflict((oc) =>
      oc.column('snowflakeId').doUpdateSet({
        name: channel.name,
        topic: topic ?? '',
      }),
    )
    .executeTakeFirst()

  log('Synced channel (#%s)', channel.name)
  channelsCache.set(channel.id, true)
}

================
File: apps/bot/db/actions/messages.ts
================
import { Message, PartialMessage } from 'discord.js'
import { db, sql } from '@nextjs-forum/db/node'
import { addPointsToUser, removePointsFromUser, syncUser } from './users.js'
import { syncChannel, syncMessageChannel } from './channels.js'
import { updatePostLastActive } from './posts.js'
import { tryToSetRegularMemberRole } from '../../lib/points.js'

export const syncMessage = async (message: Message) => {
  const authorAsGuildMember = await message.guild?.members.fetch(
    message.author.id,
  )

  await Promise.all([
    syncUser(message.author, authorAsGuildMember),
    syncMessageChannel(message.channel),
    ...message.mentions.channels.mapValues((c) => syncChannel(c)),
    ...(message.mentions.members
      ? message.mentions.members.mapValues((m) => syncUser(m.user, m))
      : []),
  ])

  await db.transaction().execute(async (trx) => {
    await trx
      .insertInto('messages')
      .values({
        snowflakeId: message.id,
        content: message.content,
        createdAt: message.createdAt,
        editedAt: message.editedAt,
        userId: message.author.id,
        postId: message.channelId,
        replyToMessageId: message.reference?.messageId,
      })
      .onConflict((oc) =>
        oc.column('snowflakeId').doUpdateSet({
          content: message.content,
          editedAt: message.editedAt,
        }),
      )
      .executeTakeFirst()

    await addPointsToUser(message.author.id, 'message', trx)

    await updatePostLastActive(message.channelId, trx)

    // Replace attachments
    if (message.attachments.size > 0) {
      await trx
        .deleteFrom('attachments')
        .where('messageId', '=', message.id)
        .execute()

      await trx
        .insertInto('attachments')
        .values(
          Array.from(message.attachments.values()).map((attachment) => ({
            snowflakeId: attachment.id,
            url: attachment.url,
            name: attachment.name,
            contentType: attachment.contentType,
            messageId: message.id,
          })),
        )
        .execute()
    }
  })

  if (authorAsGuildMember) {
    await tryToSetRegularMemberRole(authorAsGuildMember)
  }
}

export const deleteMessage = async (
  message: Message<boolean> | PartialMessage,
) => {
  await db.transaction().execute(async (trx) => {
    await trx
      .deleteFrom('messages')
      .where('snowflakeId', '=', message.id)
      .executeTakeFirst()
    await trx
      .deleteFrom('attachments')
      .where('messageId', '=', message.id)
      .execute()

    await updatePostLastActive(message.channelId, trx)

    // If the message is partial we won't remove the points of the author
    // but that is fine since it's a very minor edge case and I don't think
    // doing a fetch here is worth it
    if (message.author?.id) {
      await removePointsFromUser(message.author.id, 'message', trx)
    }
  })
}

export const markMessageAsSolution = async (
  messageId: string | null,
  postId: string,
) => {
  await db.transaction().execute(async (trx) => {
    const currentAnswer = await trx
      .selectFrom('posts')
      .innerJoin('messages', 'messages.snowflakeId', 'posts.answerId')
      .select('messages.userId')
      .where('posts.snowflakeId', '=', postId)
      .executeTakeFirst()

    if (currentAnswer) {
      await trx
        .updateTable('users')
        .set((eb) => ({
          answersCount: sql`greatest(${eb.ref('answersCount')} - 1, 0)`,
        }))
        .where('snowflakeId', '=', currentAnswer.userId)
        .execute()

      await removePointsFromUser(currentAnswer.userId, 'answer', trx)
    }

    if (messageId === null) {
      await trx
        .updateTable('posts')
        .set({ answerId: null })
        .where('snowflakeId', '=', postId)
        .executeTakeFirst()

      await updatePostLastActive(postId, trx)

      return
    }

    const newAnswer = await trx
      .selectFrom('messages')
      .select('userId')
      .where('snowflakeId', '=', messageId)
      .executeTakeFirst()

    if (newAnswer) {
      await trx
        .updateTable('posts')
        .set({ answerId: messageId })
        .where('snowflakeId', '=', postId)
        .executeTakeFirst()

      await trx
        .updateTable('users')
        .set((eb) => ({
          answersCount: sql`${eb.ref('answersCount')} + 1`,
        }))
        .where('snowflakeId', '=', newAnswer.userId)
        .execute()

      await addPointsToUser(newAnswer.userId, 'answer', trx)
      await updatePostLastActive(postId, trx)
    }
  })
}

================
File: apps/bot/db/actions/posts.ts
================
import { AnyThreadChannel } from 'discord.js'
import { db, TransactionDB, KyselyDB } from '@nextjs-forum/db/node'
import { revalidateHomePage, revalidatePost } from '../../revalidate.js'
import { removePointsFromUser } from './users.js'

export const syncPost = async (thread: AnyThreadChannel) => {
  const now = new Date()
  await db
    .insertInto('posts')
    .values({
      snowflakeId: thread.id,
      title: thread.name,
      createdAt: thread.createdAt ?? now,
      editedAt: thread.createdAt ?? now,
      isLocked: Boolean(thread.locked),
      userId: thread.ownerId,
      channelId: thread.parentId,
      lastActiveAt: now,
    })
    .onConflict((oc) =>
      oc.column('snowflakeId').doUpdateSet({
        title: thread.name,
        editedAt: now,
        isLocked: Boolean(thread.locked),
        lastActiveAt: now,
      }),
    )
    .executeTakeFirst()

  await revalidateHomePage()
}

export const deletePost = async (thread: AnyThreadChannel<boolean>) => {
  await db.transaction().execute(async (trx) => {
    await trx.deleteFrom('posts').where('snowflakeId', '=', thread.id).execute()
    await trx.deleteFrom('messages').where('postId', '=', thread.id).execute()

    if (thread.ownerId) {
      await removePointsFromUser(thread.ownerId, 'question', trx)
    }
  })
}

export const updatePostLastActive = async (
  postId: string,
  trx: TransactionDB | KyselyDB = db,
) => {
  await trx
    .updateTable('posts')
    .where('snowflakeId', '=', postId)
    .set({ lastActiveAt: new Date() })
    .execute()
}

export const unindexPost = async (channel: AnyThreadChannel<boolean>) => {
  await db
    .updateTable('posts')
    .where('snowflakeId', '=', channel.id)
    .set({ isIndexed: false })
    .execute()

  if (channel.ownerId) {
    await removePointsFromUser(channel.ownerId, 'question')
  }

  await revalidatePost(channel.id)
}

================
File: apps/bot/db/actions/users.ts
================
import { GuildMember, User } from 'discord.js'
import { baseLog } from '../../log.js'
import { KyselyDB, TransactionDB, db, sql } from '@nextjs-forum/db/node'
import { AnimalModule, Faker, en } from '@faker-js/faker'
import { type CacheUser, usersCache } from '../../lib/cache.js'
import { env } from '../../env.js'
import { POINTS_REWARDS, REQUIRED_POINTS_FOR_ROLE } from '../../lib/points.js'

const log = baseLog.extend('users')

const getDefaultAvatarForNumber = (n: number) =>
  `https://cdn.discordapp.com/embed/avatars/${n}.png`

const allowedAnimalTypes: Array<keyof AnimalModule> = [
  'bear',
  'bird',
  'cat',
  'crocodilia',
  'dog',
  'fish',
  'insect',
  'lion',
  'rabbit',
]

const userChangedCheck = (userId: string, user: CacheUser) => {
  const cachedUser = usersCache.get(userId)
  if (!cachedUser) return true
  if (cachedUser.isPublic !== user.isPublic) return true
  if (cachedUser.isModerator !== user.isModerator) return true
  if (user.isPublic) {
    if (cachedUser.username !== user.username) return true
    if (cachedUser.discriminator !== user.discriminator) return true
    if (cachedUser.avatarUrl !== user.avatarUrl) return true
  }
  return false
}

export const syncUser = async (user: User, asGuildMember?: GuildMember) => {
  let isPublicProfile = false
  let isModerator = false
  let joinedAt = asGuildMember?.joinedAt

  if (asGuildMember) {
    if (env.PUBLIC_PROFILE_ROLE_ID) {
      isPublicProfile = asGuildMember.roles.cache.has(
        env.PUBLIC_PROFILE_ROLE_ID,
      )
    }
    if (env.MODERATOR_ROLE_ID) {
      isModerator = asGuildMember.roles.cache.has(env.MODERATOR_ROLE_ID)
    }
  }

  let username = asGuildMember?.displayName || user.displayName
  let discriminator = user.discriminator
  let avatarUrl =
    asGuildMember?.displayAvatarURL({ size: 256 }) ||
    user.displayAvatarURL({ size: 256 })

  const userCheck: CacheUser = {
    username,
    discriminator,
    avatarUrl,
    isPublic: isPublicProfile,
    isModerator,
  }
  if (!userChangedCheck(user.id, userCheck)) return

  if (!isPublicProfile) {
    // The docs says its unlikely I need to create a new instance but I am afraid of using a single
    // instance while changing the seed and ending up with a race condition with another request
    const faker = new Faker({ locale: en })
    faker.seed(user.id.split('').map(Number))
    // Generate a hopefully cool animal name because I thought the person names were looking too fake
    const animalType = faker.helpers.arrayElement(allowedAnimalTypes)
    const animalName = faker.animal[animalType]()

    username = animalName
    discriminator = faker.string.numeric(4)
    avatarUrl = getDefaultAvatarForNumber(faker.number.int({ min: 0, max: 5 }))
  }

  await db
    .insertInto('users')
    .values({
      snowflakeId: user.id,
      isPublic: isPublicProfile,
      isModerator,
      username,
      discriminator,
      avatarUrl,
      joinedAt: joinedAt ?? undefined,
    })
    .onConflict((oc) =>
      oc.column('snowflakeId').doUpdateSet({
        isPublic: isPublicProfile,
        isModerator,
        username,
        discriminator,
        avatarUrl,
        joinedAt: joinedAt ?? undefined,
      }),
    )
    .executeTakeFirst()

  log('Synced user (%s)', user.id)
  usersCache.set(user.id, userCheck)
}

export const getUserById = (id: string) => {
  return db
    .selectFrom('users')
    .select(['username', 'points'])
    .where('snowflakeId', '=', id)
    .executeTakeFirst()
}

const updatePointsBySum = async (
  userId: string,
  value: number,
  trx: TransactionDB | KyselyDB = db,
) => {
  await trx
    .updateTable('users')
    .where('snowflakeId', '=', userId)
    .set((eb) => ({
      points: sql`LEAST(999999, ${eb.ref('points')} + ${value})`,
    }))
    .execute()
}

const updatePointsBySet = async (
  userId: string,
  value: number,
  trx: TransactionDB | KyselyDB = db,
) => {
  await trx
    .updateTable('users')
    .where('snowflakeId', '=', userId)
    .set({ points: sql`LEAST(999999, ${value})` })
    .execute()
}

export const addPointsToUser = async (
  userId: string,
  type: keyof typeof POINTS_REWARDS,
  trx: TransactionDB | KyselyDB = db,
) => updatePointsBySum(userId, POINTS_REWARDS[type], trx)

export const addFullPointsToUser = async (
  userId: string,
  trx: TransactionDB | KyselyDB = db,
) => updatePointsBySet(userId, REQUIRED_POINTS_FOR_ROLE, trx)

export const removePointsFromUser = async (
  userId: string,
  type: keyof typeof POINTS_REWARDS,
  trx: TransactionDB | KyselyDB = db,
) => updatePointsBySum(userId, -POINTS_REWARDS[type], trx)

export const removeFullPointsFromUser = async (
  userId: string,
  trx: TransactionDB | KyselyDB = db,
) => updatePointsBySet(userId, 0, trx)

export const getCorrectAnswersCount = (userId: string) => {
  return db
    .selectFrom('users')
    .where('snowflakeId', '=', userId)
    .select(['answersCount'])
    .executeTakeFirst()
}

================
File: apps/bot/lib/cache.ts
================
import { LRUCache } from 'lru-cache'

export const usersCache = new LRUCache<string, CacheUser>({ max: 100 })
export const channelsCache = new LRUCache<string, boolean>({ max: 10 })

export interface CacheUser {
  username: string
  discriminator: string
  avatarUrl: string
  isPublic?: boolean
  isModerator?: boolean
  joinedAt?: Date
}

================
File: apps/bot/lib/points.ts
================
import { LRUCache } from 'lru-cache'
import { env } from '../env.js'
import { Colors, GuildMember } from 'discord.js'
import { getUserById } from '../db/actions/users.js'

export const POINTS_REWARDS = {
  message: 2,
  question: 20,
  answer: 50,
} as const
export const REQUIRED_POINTS_FOR_ROLE = 1000

const USER_ROLE_SYNC_INTERVAL = 1000 * 60 * 60 // 1 hour

const lastUserSync = new LRUCache<string, number>({ max: 100 })

export const tryToSetRegularMemberRole = async (
  member: GuildMember,
  skipCache: boolean = false,
) => {
  if (!env.REGULAR_MEMBER_ROLE_ID) return

  const lastSync = lastUserSync.get(member.id)
  if (
    !skipCache &&
    lastSync &&
    Date.now() - lastSync < USER_ROLE_SYNC_INTERVAL
  ) {
    return
  }

  lastUserSync.set(member.id, Date.now())

  const user = await getUserById(member.id)
  if (!user) return

  const userPointsSatisfyRole = user.points >= REQUIRED_POINTS_FOR_ROLE
  const memberHasRole = member.roles.cache.has(env.REGULAR_MEMBER_ROLE_ID)

  if (memberHasRole && userPointsSatisfyRole) return
  if (!memberHasRole && !userPointsSatisfyRole) return

  if (memberHasRole && !userPointsSatisfyRole) {
    await member.roles.remove(env.REGULAR_MEMBER_ROLE_ID)
    // We don't need to alert the user about this.
    return
  }

  // Now, it is !memberHasRole && userPointsSatisfyRole
  await member.roles.add(env.REGULAR_MEMBER_ROLE_ID)
  await member.send({
    embeds: [
      {
        color: Colors.Blurple,
        title: 'New role assigned',
        description:
          'You have been assigned the Regular Member role! This role is given to users who have contributed to the community by helping other users and/or participating on the server. Thank you for your contributions!',
      },
    ],
  })
}

================
File: apps/bot/env.ts
================
import { createEnv } from '@t3-oss/env-core'
import dotenv from 'dotenv'
import { z } from 'zod'

dotenv.config()

export const env = createEnv({
  server: {
    // Node.js (set by the CLI)
    NODE_ENV: z
      .union([z.literal('development'), z.literal('production')])
      .default('production'),

    // Discord
    DISCORD_BOT_TOKEN: z.string(),
    DISCORD_CLIENT_ID: z.string(),
    DEV_GUILD_ID: z.string().optional(),
    PUBLIC_PROFILE_ROLE_ID: z.string().optional(),
    MODERATOR_ROLE_ID: z.string().optional(),
    HELPER_ROLE_ID: z.string().optional(),
    REGULAR_MEMBER_ROLE_ID: z.string().optional(),
    INDEXABLE_CHANNEL_IDS: z.string().transform((str) => str.split(',')),
    MOD_LOG_CHANNEL_ID: z.string().optional(),

    // Database
    DATABASE_URL: z.string(),

    // Web
    REVALIDATE_SECRET: z.string(),
    WEB_URL: z.string(),

    // Migrations (set by the CLI)
    MIGRATE_OP: z.union([z.literal('latest'), z.literal('down')]).optional(),
  },

  runtimeEnv: process.env,
})

================
File: apps/bot/index.ts
================
import { Colors, Events, GatewayIntentBits, Partials, Client } from 'discord.js'
import { dedent } from 'ts-dedent'
import { env } from './env.js'
import { deleteMessage, syncMessage } from './db/actions/messages.js'
import { deletePost, syncPost } from './db/actions/posts.js'
import { baseLog } from './log.js'
import {
  isMessageInForumChannel,
  isMessageSupported,
  isThreadInForumChannel,
  isThreadSupported,
} from './utils.js'
import { contextMenuCommands } from './commands/context/index.js'
import { slashCommands } from './commands/slash/index.js'
import { addPointsToUser, syncUser } from './db/actions/users.js'

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.MessageContent,
  ],
  partials: [Partials.Message],
})

client.once(Events.ClientReady, (c) => {
  baseLog(`Ready! Logged in as ${c.user.tag}`)
})

client.on(Events.MessageCreate, async (message) => {
  if (
    !isMessageInForumChannel(message.channel) ||
    !isMessageSupported(message)
  ) {
    return
  }

  try {
    await syncMessage(message)
    baseLog('Created a new message in post %s', message.channelId)
  } catch (err) {
    console.error('Failed to create message:', err)
  }
})

client.on(Events.MessageUpdate, async (_, newMessage) => {
  if (!isMessageInForumChannel(newMessage.channel)) return

  try {
    const message = await newMessage.fetch()
    if (!isMessageSupported(message)) return

    await syncMessage(message)
    baseLog('Updated a message in post %s', message.channelId)
  } catch (err) {
    console.error('Failed to update message:', err)
  }
})

client.on(Events.MessageDelete, async (message) => {
  if (!isMessageInForumChannel(message.channel)) return

  try {
    await deleteMessage(message)
    baseLog('Deleted a message in post %s', message.channelId)
  } catch (err) {
    console.error('Failed to delete message:', err)
  }
})

client.on(Events.ThreadCreate, async (thread) => {
  if (!isThreadInForumChannel(thread) || !isThreadSupported(thread)) return

  try {
    await syncPost(thread)
    baseLog('Created a new post (%s)', thread.id)

    if (thread.ownerId) {
      await addPointsToUser(thread.ownerId, 'question')
    }

    await thread.send({
      embeds: [
        {
          title: 'Post created!',
          description: dedent`
            üîé This post has been indexed in our web forum and will be seen by search engines so other users can find it outside Discord

            üïµÔ∏è Your user profile is private by default and won't be visible to users outside Discord, if you want to be visible in the web forum you can add the "Public Profile" role in <id:customize>

            ‚úÖ You can mark a message as the answer for your post with \`Right click -> Apps -> Mark Solution\`
            (if you don't see the option, try refreshing Discord with Ctrl + R)
          `,
          color: Colors.Blurple,
          image: {
            url: 'https://cdn.discordapp.com/attachments/1043615796787683408/1117191182133501962/image.png',
          },
          url: `${env.WEB_URL}/post/${thread.id}`,
        },
      ],
    })
  } catch (err) {
    console.error('Failed to create thread:', err)
  }
})

client.on(Events.ThreadUpdate, async (_, newThread) => {
  if (!isThreadInForumChannel(newThread) || !isThreadSupported(newThread)) {
    return
  }

  try {
    await syncPost(newThread)
    baseLog('Updated a post (%s)', newThread.id)
  } catch (err) {
    console.error('Failed to update thread:', err)
  }
})

client.on(Events.ThreadDelete, async (thread) => {
  if (!isThreadInForumChannel(thread) || !isThreadSupported(thread)) return

  try {
    await deletePost(thread)
    baseLog('Deleted a post (%s)', thread.id)
  } catch (err) {
    console.error('Failed to delete thread:', err)
  }
})

client.on(Events.GuildMemberUpdate, async (oldMember, newMember) => {
  if (newMember.user.bot) return
  await syncUser(newMember.user, newMember)
})

client.on(Events.InteractionCreate, async (interaction) => {
  if (interaction.isMessageContextMenuCommand()) {
    contextMenuCommands
      .find((c) => c.data.name === interaction.commandName)
      ?.execute(interaction)
  }

  if (interaction.isChatInputCommand()) {
    slashCommands
      ?.find((c) => c.data.name === interaction.commandName)
      ?.execute(interaction)
  }
})

client.login(env.DISCORD_BOT_TOKEN)

================
File: apps/bot/log.ts
================
import debug from 'debug'

debug.enable('discord,discord:*')

// @ts-expect-error: https://github.com/debug-js/debug/issues/922#issuecomment-1374524350
debug.useColors = () => true

export const baseLog = debug('discord')

================
File: apps/bot/package.json
================
{
  "name": "@nextjs-forum/bot",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "NODE_ENV=development NODE_OPTIONS='--loader ts-node/esm' nodemon index.ts",
    "build": "tsc --build",
    "start": "NODE_ENV=production node build/index.js",
    "dev:register-commands": "NODE_ENV=development node --loader ts-node/esm ./register-commands.ts",
    "register-commands": "node --loader ts-node/esm ./register-commands.ts"
  },
  "dependencies": {
    "@faker-js/faker": "^8.4.1",
    "@nextjs-forum/db": "workspace:*",
    "@t3-oss/env-core": "^0.9.2",
    "debug": "^4.3.4",
    "discord.js": "^14.12.1",
    "dotenv": "^16.4.5",
    "lru-cache": "^10.2.0",
    "ts-dedent": "^2.2.0",
    "zod": "^3.21.4"
  },
  "devDependencies": {
    "@nextjs-forum/eslint-config-custom": "workspace:*",
    "@nextjs-forum/tsconfig": "workspace:*",
    "@types/debug": "^4.1.8",
    "@types/node": "^20.12.2",
    "eslint": "^8.57.0",
    "nodemon": "^3.1.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.3"
  }
}

================
File: apps/bot/register-commands.ts
================
import { REST, Routes } from 'discord.js'
import { env } from './env.js'
import { contextMenuCommands } from './commands/context/index.js'
import { slashCommands } from './commands/slash/index.js'

const isDevRegister = env.NODE_ENV === 'development'
const guildId = env.DEV_GUILD_ID

if (isDevRegister && !guildId) {
  throw new Error(
    'The DEV_GUILD_ID env variable should be set to register commands in dev',
  )
}

const commands = [
  ...contextMenuCommands.map((file) => file.data.toJSON()),
  ...slashCommands.map((file) => file.data.toJSON()),
]

const rest = new REST({ version: '10' }).setToken(env.DISCORD_BOT_TOKEN)

console.log(`Started refreshing ${commands.length} application commands.`)

const data = (await rest.put(
  isDevRegister
    ? Routes.applicationGuildCommands(env.DISCORD_CLIENT_ID, guildId ?? '')
    : Routes.applicationCommands(env.DISCORD_CLIENT_ID),
  { body: commands },
)) as unknown[]

console.log(`Successfully reloaded ${data.length} application commands.`)

================
File: apps/bot/revalidate.ts
================
import { env } from './env.js'

const post = (endpoint: string, body?: Record<string, unknown>) => {
  return fetch(`${env.WEB_URL}${endpoint}`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${env.REVALIDATE_SECRET}`,
      'Content-Type': 'application/json',
    },
    body: body ? JSON.stringify(body) : undefined,
  })
}

export const revalidateHomePage = () => {
  return post('/api/revalidate-home')
}

export const revalidatePost = (postId: string) => {
  return post(`/api/revalidate-post`, { postId })
}

================
File: apps/bot/tsconfig.json
================
{
  "extends": "@nextjs-forum/tsconfig/node.json",
  "compilerOptions": {
    "outDir": "build"
  },
  "exclude": ["build"],
  "references": [{ "path": "../../packages/db" }]
}

================
File: apps/bot/utils.ts
================
import {
  Channel,
  AnyThreadChannel,
  Message,
  APIEmbed,
  Colors,
  InteractionReplyOptions,
  InteractionResponse,
} from 'discord.js'
import { env } from './env.js'

const START_INDEXING_AFTER = 1686438000000

export const isMessageInForumChannel = (
  channel: Channel,
): channel is AnyThreadChannel<true> => {
  return (
    channel.isThread() &&
    channel.parentId !== null &&
    env.INDEXABLE_CHANNEL_IDS.includes(channel.parentId)
  )
}

export const isMessageSupported = (message: Message) => {
  const isIndexable = message.createdAt.getTime() > START_INDEXING_AFTER
  return !message.author.bot && !message.system && isIndexable
}

export const isThreadSupported = (thread: AnyThreadChannel<true>) => {
  const isIndexable =
    thread.createdAt !== null &&
    thread.createdAt.getTime() > START_INDEXING_AFTER
  return isIndexable
}

export const isThreadInForumChannel = (thread: AnyThreadChannel<true>) => {
  return (
    thread.parentId !== null &&
    env.INDEXABLE_CHANNEL_IDS.includes(thread.parentId)
  )
}

type Replyable = {
  reply: (content: InteractionReplyOptions) => Promise<InteractionResponse>
}

export const replyWithEmbed = (
  replyable: Replyable,
  { color = Colors.Blue, ...opts }: APIEmbed,
) => {
  return replyable.reply({
    embeds: [
      {
        color,
        ...opts,
      },
    ],
  })
}

export const replyWithEmbedError = (
  replyable: Replyable,
  { title = '‚ùå Error!', color = Colors.Red, ...opts }: APIEmbed,
) => {
  return replyable.reply({
    ephemeral: true,
    embeds: [
      {
        title,
        color,
        ...opts,
      },
    ],
  })
}

================
File: apps/web/.vscode/settings.json
================
{
  "typescript.tsdk": "../../node_modules/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true
}

================
File: apps/web/app/(home)/page/[page]/page.tsx
================
import { notFound } from 'next/navigation'
import { Metadata } from 'next'
import { getBaseUrl } from '@/utils/urls'
import { PostsList } from '@/components/posts-list'

// This page is probably temporary, it doesn't benefit SEO so
// it's probably a good idea to replace it with an infinite scroll
// in the home page. We can decide which paginating method is better
// later on if we create a search page

export const metadata: Metadata = {
  // Avoid indexing the pagination pages
  alternates: { canonical: getBaseUrl() },
  robots: {
    index: false,
    follow: false,
  },
}

type Params = { page: string }
type PaginationPageProps = { params: Params }

const PaginationPage = async ({ params }: PaginationPageProps) => {
  // Only positive integers
  if (!/^\d+$/g.test(params.page)) {
    notFound()
  }

  const page = parseInt(params.page, 10)
  if (Number.isNaN(page) || page < 1) {
    notFound()
  }

  return <PostsList page={page} />
}

export default PaginationPage

================
File: apps/web/app/(home)/layout.tsx
================
import { LayoutWithSidebar } from '@/components/layout-with-sidebar'
import Balancer from 'react-wrap-balancer'
import discordImage from '@/discord.png'
import Image from 'next/image'
import { ReactNode } from 'react'

type HomeLayoutProps = { children: ReactNode }

export default function HomeLayout({ children }: HomeLayoutProps) {
  return (
    <>
      <div className="relative py-16 border-b border-neutral-800 bg-gradient-to-t from-neutral-900 to-neutral-800 overflow-hidden">
        <div className="container max-w-7xl mx-auto flex items-center">
          <div className="flex-1 flex flex-col px-4 space-y-4 z-10 text-center lg:text-left">
            <h2 className="font-semibold text-5xl lg:max-w-2xl leading-[1.1]">
              <Balancer ratio={0.75}>
                The Fleek Discord server indexed in the web.
              </Balancer>
            </h2>
            <a
              href="https://discord.gg/fleek"
              target="_blank"
              rel="noopener"
              className="mx-auto text-xl text-white w-fit hover:opacity-80 hover:no-underline transition-opacity lg:mx-0"
            >
              Join the server ‚ûî
            </a>
          </div>

          <div
            className="hidden lg:flex absolute top-0 bottom-0 left-1/2"
            style={{
              WebkitMaskImage:
                'linear-gradient(to bottom, rgba(0, 0, 0, 1.0) 50%, transparent 100%)',
              maskImage:
                'linear-gradient(to top, rgba(0, 0, 0, 1.0) 0%, transparent 100%)',
            }}
          >
            <div>
              <Image
                src={discordImage}
                alt=""
                quality={90}
                className="block relative -top-11 -skew-x-3 opacity-90 "
                style={{
                  WebkitMaskImage:
                    'linear-gradient(to right, transparent 0%, rgba(0, 0, 0, 1.0) 20%, rgba(0, 0, 0, 1.0) 80%, transparent 100%)',
                  maskImage:
                    'linear-gradient(to top, rgba(0, 0, 0, 1.0) 0%, transparent 100%)',
                }}
              />
            </div>
          </div>
        </div>
      </div>

      <LayoutWithSidebar>{children}</LayoutWithSidebar>
    </>
  )
}

================
File: apps/web/app/(home)/page.tsx
================
import { PostsList } from '@/components/posts-list'

export const dynamic = 'error'
export const revalidate = 60

const Home = async () => {
  return <PostsList page={1} />
}

export default Home

================
File: apps/web/app/post/[id]/page.tsx
================
import '../../discord-markdown.css'

import { Metadata } from 'next'
import { notFound } from 'next/navigation'
import plur from 'plur'
import { db, sql } from '@nextjs-forum/db/node'
import { Message } from '@/components/message'
import { LayoutWithSidebar } from '@/components/layout-with-sidebar'
import { groupMessagesByUser } from '@/utils/group-messages'
import { MessageGroup } from '@/components/message-group'
import { truncate } from '@/utils/truncate'
import { getCanonicalPostUrl } from '@/utils/urls'
import { CheckCircleSolidIcon } from '@/components/icons/check-circle-solid'
import { Attachment, MessageContent } from '@/components/message-content'
import { ArrowDownIcon } from '@/components/icons/arrow-down'
import type { QAPage, WithContext } from 'schema-dts'
import { parseDiscordMessage } from '@/utils/discord-markdown'
import Link from 'next/link'

const isPostIndexed = async (snowflakeId: string) => {
  const post = await db
    .selectFrom('posts')
    .select('isIndexed')
    .where('snowflakeId', '=', snowflakeId)
    .executeTakeFirst()

  return post ? post.isIndexed : false
}

const getPost = async (snowflakeId: string) => {
  return await db
    .selectFrom('posts')
    .innerJoin('users', 'users.snowflakeId', 'posts.userId')
    .innerJoin('channels', 'channels.snowflakeId', 'posts.channelId')
    .select([
      'posts.id',
      'posts.snowflakeId',
      'posts.title',
      'posts.createdAt',
      'posts.answerId',
      'users.username',
      'users.isPublic as userIsPublic',
      'users.avatarUrl as userAvatar',
      'channels.name as channelName',
      'users.snowflakeId as userID',
      (eb) =>
        eb
          .selectFrom('messages')
          .select(eb.fn.countAll<number>().as('count'))
          .where('messages.postId', '=', eb.ref('posts.snowflakeId'))
          .as('messagesCount'),
    ])
    .where('posts.snowflakeId', '=', snowflakeId)
    .executeTakeFirst()
}

const getPostMessage = async (postId: string) => {
  return await db
    .selectFrom('messages')
    .leftJoin('attachments', 'attachments.messageId', 'messages.snowflakeId')
    .innerJoin('users', 'users.snowflakeId', 'messages.userId')
    .select([
      'messages.id',
      'messages.content',
      'messages.createdAt',
      'users.id as authorId',
      'users.avatarUrl as authorAvatarUrl',
      'users.username as authorUsername',
      'users.isPublic as userIsPublic',
      'users.isModerator as userIsModerator',
      'users.snowflakeId as userID',
      sql<Attachment[]>`
        coalesce(json_agg(
          json_build_object(
            'id', attachments.id,
            'url', attachments.url,
            'name', attachments.name,
            'contentType', attachments."contentType"
          )
        ) filter (where attachments.id is not null), '[]'::json)
      `.as('attachments'),
    ])
    .where('messages.postId', '=', postId)
    .where('messages.snowflakeId', '=', postId)
    .groupBy(['messages.id', 'users.id'])
    .orderBy('messages.createdAt', 'asc')
    .executeTakeFirst()
}

const getMessages = async (postId: string) => {
  return await db
    .selectFrom('messages')
    .leftJoin('attachments', 'attachments.messageId', 'messages.snowflakeId')
    .innerJoin('users', 'users.snowflakeId', 'messages.userId')
    .select([
      'messages.id',
      'messages.snowflakeId',
      'messages.content',
      'messages.createdAt',
      'users.id as authorId',
      'users.avatarUrl as authorAvatarUrl',
      'users.username as authorUsername',
      'users.isPublic as userIsPublic',
      'users.isModerator as userIsModerator',
      'users.snowflakeId as userID',
      sql<Attachment[]>`
        coalesce(json_agg(
          json_build_object(
            'id', attachments.id,
            'url', attachments.url,
            'name', attachments.name,
            'contentType', attachments."contentType"
          )
        ) filter (where attachments.id is not null), '[]'::json)
      `.as('attachments'),
    ])
    .where('postId', '=', postId)
    .where('messages.snowflakeId', '!=', postId)
    .groupBy(['messages.id', 'users.id'])
    .orderBy('messages.createdAt', 'asc')
    .execute()
}

// Since we have a lot of messages in a short period for posts, we will only revalidate it
// at most once every 60 seconds
export const dynamic = 'error'
export const revalidate = 60

export const generateMetadata = async ({
  params,
}: PostProps): Promise<Metadata> => {
  const post = await getPost(params.id)
  const postMessage = await getPostMessage(params.id)

  const title = post?.title
  const postMessageFormatted = await parseDiscordMessage(
    postMessage?.content || '',
    true,
  )
  const description = truncate(postMessageFormatted, 230)
  const url = getCanonicalPostUrl(params.id)

  return {
    title,
    description,
    alternates: {
      canonical: url,
    },
    openGraph: {
      title,
      description,
      url,
      type: 'website',
      siteName: 'Fleek Discord Forum',
    },
    twitter: {
      card: 'summary',
      title,
      description,
    },
  }
}

type PostProps = {
  params: { id: string }
}

const Post = async ({ params }: PostProps) => {
  const isIndexed = await isPostIndexed(params.id)
  if (!isIndexed) {
    notFound()
  }

  const post = await getPost(params.id)
  if (!post) {
    notFound()
  }

  const messages = await getMessages(params.id)
  const postMessage = await getPostMessage(params.id)
  const answerMessage = messages.find((m) => m.snowflakeId === post.answerId)
  const groupedMessages = groupMessagesByUser(messages, post.answerId)
  const hasAnswer =
    post.answerId && messages.some((m) => m.snowflakeId === post.answerId)
  const truncatedName = truncate(post.username, 32)

  const jsonLd: WithContext<QAPage> = {
    '@context': 'https://schema.org',
    '@type': 'QAPage',
    mainEntity: {
      '@type': 'Question',
      name: post.title,
      text: postMessage
        ? await parseDiscordMessage(postMessage?.content, true)
        : 'Original message was deleted.',
      dateCreated: post.createdAt.toJSON(),
      answerCount: messages.length,
      author: {
        '@type': 'Person',
        name: post.username,
      },
      acceptedAnswer:
        hasAnswer && answerMessage
          ? {
              '@type': 'Answer',
              text: await parseDiscordMessage(answerMessage.content, true),
              url: `${getCanonicalPostUrl(params.id)}#message-${
                answerMessage.snowflakeId
              }`,
              dateCreated: answerMessage.createdAt.toJSON(),
              author: {
                '@type': 'Person',
                name: answerMessage.authorUsername,
              },
              upvoteCount: 1,
            }
          : undefined,
      suggestedAnswer:
        !hasAnswer && messages[0]
          ? {
              '@type': 'Answer',
              text: await parseDiscordMessage(messages[0].content, true),
              url: `${getCanonicalPostUrl(params.id)}#message-${
                messages[0].snowflakeId
              }`,
              dateCreated: messages[0].createdAt.toJSON(),
              author: {
                '@type': 'Person',
                name: messages[0].authorUsername,
              },
            }
          : undefined,
    },
  }

  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <LayoutWithSidebar className="mt-4">
        <div>
          <h1 className="mb-4 font-semibold text-3xl">{post.title}</h1>

          <div className="flex flex-col sm:flex-row gap-2 sm:items-center justify-between">
            <div className="flex flex-wrap items-center gap-2">
              {hasAnswer ? (
                <div className="px-2.5 py-1 border border-green-400 text-green-400 rounded-full opacity-60">
                  Answered
                </div>
              ) : (
                <div className="px-2.5 py-1 border rounded-full opacity-50">
                  Unanswered
                </div>
              )}
              <div>
                {post.userIsPublic ? (
                  <Link
                    className=" text-white opacity-90"
                    href={`/user/${post.userID}`}
                  >
                    {truncatedName}
                  </Link>
                ) : (
                  truncatedName
                )}{' '}
                <span className="opacity-50">
                  posted this in{' '}
                  <span className=" font-semibold">#{post.channelName}</span>
                </span>
              </div>
            </div>

            <a
              href={`https://discord.com/channels/752553802359505017/${post.snowflakeId}/${post.snowflakeId}`}
              className="shrink-0 w-fit px-4 py-1.5 font-semibold text-white border-neutral-700 border rounded hover:bg-neutral-700 hover:no-underline transition-colors"
              target="_blank"
              rel="noopener noreferrer"
            >
              Open in Discord
            </a>
          </div>
        </div>

        <div className="mt-4 space-y-1">
          <MessageGroup isAnswer={false}>
            {postMessage ? (
              <Message
                snowflakeId={postMessage.id.toString()}
                createdAt={postMessage.createdAt}
                content={postMessage.content}
                author={{
                  username: postMessage.authorUsername,
                  avatarUrl: postMessage.authorAvatarUrl,
                  isPublic: postMessage.userIsPublic,
                  isOP: true,
                  isModerator: postMessage.userIsModerator,
                  userID: postMessage.userID,
                }}
                attachments={postMessage.attachments}
                isFirstRow
              />
            ) : (
              <span className="px-4 opacity-80">
                Original message was deleted.
              </span>
            )}
          </MessageGroup>

          {answerMessage && (
            <div className="p-2 sm:p-3 space-y-1.5 border border-green-400 rounded">
              <div className="flex space-x-2 items-center text-green-400">
                <CheckCircleSolidIcon />
                <div className="text-sm">
                  Answered by{' '}
                  <span className="font-semibold">
                    {answerMessage.authorUsername}
                  </span>
                </div>
              </div>

              <div
                className="max-h-32 overflow-hidden"
                style={{
                  WebkitMaskImage:
                    'linear-gradient(180deg, #000 80%, transparent)',
                  maskImage: 'linear-gradient(180deg, #000 80%, transparent)',
                }}
              >
                <MessageContent
                  content={answerMessage.content}
                  attachments={answerMessage.attachments}
                />
              </div>

              <a
                href={`#message-${answerMessage.snowflakeId}`}
                className="mt-2 opacity-80 font-semibold text-sm space-x-1"
              >
                <span>View full answer</span>
                <ArrowDownIcon size={4} />
              </a>
            </div>
          )}
        </div>

        <h2 className="my-4 text-lg font-semibold">
          {messages.length} {plur('Reply', messages.length)}
        </h2>

        <div className="space-y-2">
          {groupedMessages.map((group) => (
            <MessageGroup
              key={group.id}
              isAnswer={group.messages.some(
                (m) => m.snowflakeId === post.answerId,
              )}
            >
              {group.messages.map((message, i) => (
                <Message
                  key={message.id.toString()}
                  snowflakeId={message.snowflakeId}
                  createdAt={message.createdAt}
                  content={message.content}
                  isFirstRow={i === 0}
                  author={{
                    username: message.authorUsername,
                    avatarUrl: message.authorAvatarUrl,
                    isPublic: message.userIsPublic,
                    isOP: postMessage
                      ? message.authorId === postMessage.authorId
                      : false,
                    isModerator: message.userIsModerator,
                    userID: message.userID,
                  }}
                  attachments={message.attachments}
                />
              ))}
            </MessageGroup>
          ))}
        </div>
      </LayoutWithSidebar>
    </>
  )
}

export default Post

================
File: apps/web/app/user/[discordID]/page.tsx
================
import { CalendarPlusIcon } from '@/components/icons/calender-plus'
import { HeartIcon } from '@/components/icons/heart'
import { MedalIcon } from '@/components/icons/medal'
import { Post } from '@/components/post'
import { getCanonicalUserUrl } from '@/utils/urls'
import { Metadata } from 'next'
import { db, sql } from '@nextjs-forum/db/node'
import { notFound } from 'next/navigation'
const getLeaderboardPosition = async (discordID: string) => {
  const result = await db
    .with('rankedUsers', (db) =>
      db
        .selectFrom('users')
        .select([
          'snowflakeId',
          sql<number>`RANK() OVER (ORDER BY COALESCE("answersCount", 0) DESC, "snowflakeId" DESC)`.as(
            'position',
          ),
        ]),
    )
    .selectFrom('rankedUsers')
    .select(['snowflakeId', 'position'])
    .where('snowflakeId', '=', discordID)
    .execute()

  return result.length > 0 ? result[0].position : null
}

const getUserData = async (discordID: string) => {
  const userData = await db
    .selectFrom('users')
    .select([
      'snowflakeId',
      'username',
      'avatarUrl',
      'answersCount',
      'isPublic',
      'joinedAt',
    ])
    .where('snowflakeId', '=', discordID)
    .executeTakeFirst()

  if (!userData) {
    return null
  }

  const position = await getLeaderboardPosition(discordID)

  return { ...userData, leaderBoardPosition: position ?? null }
}

const getUserPosts = async (discordID: string) => {
  // First query to get posts
  const posts = await db
    .selectFrom('posts')
    .innerJoin('messages', 'posts.answerId', 'messages.snowflakeId')
    .select(['posts.id']) // Select more as needed
    .where('messages.userId', '=', discordID)
    .limit(5)
    .execute()

  // Extract post IDs from the first query results
  const postIds = posts.map((post) => post.id)
  if (postIds.length === 0) {
    return []
  }
  // Second query to get additional details for the posts
  const detailedPosts = await db
    .selectFrom('posts')
    .where('posts.id', 'in', postIds)
    .innerJoin('users', 'users.snowflakeId', 'posts.userId')
    .leftJoin('messages', 'messages.snowflakeId', 'posts.answerId')
    .select([
      'posts.id',
      'posts.snowflakeId',
      'posts.title',
      'posts.createdAt',
      'users.username',
      'users.avatarUrl as userAvatar',
      sql<boolean>`messages.id is not null`.as('hasAnswer'),
      (eb) =>
        eb
          .selectFrom('messages')
          .select(eb.fn.countAll<string>().as('count'))
          .where('messages.postId', '=', eb.ref('posts.snowflakeId'))
          .where('messages.snowflakeId', '!=', eb.ref('posts.snowflakeId'))
          .as('messagesCount') as any, // Ensure the return type matches AliasedSelectQueryBuilder
    ])
    .execute()

  return detailedPosts
}

export const generateMetadata = async ({
  params,
}: UserProps): Promise<Metadata> => {
  const userData = await getUserData(params.discordID)
  if (!userData || !userData.isPublic) {
    return notFound()
  }
  const title = userData.username
  const description = `${userData.username}'s profile on the Fleek Discord Forum`
  const url = getCanonicalUserUrl(params.discordID)

  return {
    title,
    description,
    alternates: {
      canonical: url,
    },
    openGraph: {
      title,
      description,
      url,
      type: 'website',
      siteName: 'Fleek Discord Forum',
    },
    twitter: {
      card: 'summary',
      title,
      description,
    },
  }
}

type UserProps = {
  params: { discordID: string }
}

const UserInfo = async ({ params }: UserProps) => {
  const userData = await getUserData(params.discordID)
  if (!userData || !userData.isPublic) {
    return notFound()
  }
  const recentPosts = await getUserPosts(params.discordID)

  return (
    <main className="w-full h-full flex flex-col items-center justify-center">
      <section className="w-full h-full flex flex-col xl:flex-row items-stretch justify-center max-w-7xl px-4 py-12 xl:py-16 gap-4 xl:gap-10">
        <div className="w-fit min-w-[20%] md:max-w-[50%] xl:max-w-[30%] flex flex-row items-stretch justify-start gap-4 shrink-0">
          <img
            className="size-16 rounded-full"
            src={userData.avatarUrl}
            alt={`User Avatar of ${userData.username}`}
          />
          <div className="w-fit   h-auto flex flex-col items-start justify-start gap-1 ">
            <h1 className="text-xl md:text-2xl font-semibold text-white line-clamp-1">
              {userData.username}
            </h1>
            {userData.leaderBoardPosition && (
              <div className="flex flex-row items-center justify-center gap-1 w-fit h-fit opacity-80 pt-1 ">
                <MedalIcon size={4} className="mb-[1px]" />{' '}
                <p className="text-sm h-fit">
                  Leaderboard Position:{' '}
                  <span className="opacity-60">
                    {userData.leaderBoardPosition}
                  </span>
                </p>
              </div>
            )}
            {/* joinedAt can be nulled, as it could be in discord.js */}
            {userData.joinedAt && (
              <div className=" flex flex-row items-center justify-center gap-1 w-fit h-fit opacity-80 ">
                <CalendarPlusIcon size={4} className="mb-[1px]" />{' '}
                <p className="text-sm h-fit">
                  Joined:{' '}
                  <span className="opacity-60">
                    {userData.joinedAt?.toLocaleDateString()}
                  </span>
                </p>
              </div>
            )}
            <div className=" flex flex-row items-center justify-center gap-1 w-fit h-fit opacity-80 ">
              <HeartIcon size={4} className="mb-[1px]" />{' '}
              <p className="text-sm h-fit">
                Total Answers:{' '}
                <span className="text-green-500">{userData.answersCount}</span>
              </p>
            </div>
          </div>
        </div>
        <div className="w-full h-[1px] xl:w-[1px] bg-white/10 xl:h-auto mt-3 xl:mt-0"></div>
        <div className="w-full h-fit flex flex-col items-stretch justify-start gap-4  xl:py-0">
          {recentPosts.length > 0 ? (
            recentPosts.map((post) => (
              <Post
                key={post.id}
                id={post.snowflakeId}
                title={post.title}
                createdAt={post.createdAt}
                messagesCount={parseInt(post.messagesCount ?? '0', 10)}
                hasAnswer={post.hasAnswer}
                author={{ avatar: post.userAvatar, username: post.username }}
              />
            ))
          ) : (
            <p className="text-center text-lg">
              The user has no marked answers yet
            </p>
          )}
        </div>
      </section>
    </main>
  )
}

export default UserInfo

================
File: apps/web/app/discord-markdown.css
================
.d-emoji {
  object-fit: contain;
  width: 22px;
  height: 22px;
  vertical-align: bottom;
  display: inline-block;
}

.d-code-block {
  margin-top: 6px;
  border: 1px solid rgba(100, 100, 100, 0.5);
  font-size: 14px;
}

.d-code-block,
.d-code-block code {
  border-radius: 4px;
}

.d-code-block code.hljs {
  padding: 0.5em;
}

.d-code-inline {
  padding: 0.2em 0.3em;
  font-family: ui-monospace, monospace;
  font-size: 85%;
  background: rgba(100, 100, 100, 0.4);
  border-radius: 4px;
  white-space: pre-wrap;
}

.d-mention {
  @apply px-0.5 text-white bg-[#7f8aff40] rounded font-medium;
}

================
File: apps/web/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  a {
    @apply text-blue-400;
  }
  a:hover {
    @apply underline;
  }
}

html {
  scroll-behavior: smooth;
}

================
File: apps/web/app/layout.tsx
================
import { ReactNode } from 'react'
import { Inter } from 'next/font/google'
import { Analytics } from '@vercel/analytics/react'

import './globals.css'
import { GitHubIcon } from '../components/icons/github'
import { LogoIcon } from '../components/icons/next'
import { DiscordIcon } from '../components/icons/discord'
import { Metadata } from 'next'
import { getBaseUrl } from '../utils/urls'

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})

export const metadata: Metadata = {
  metadataBase: new URL(getBaseUrl()),
  title: {
    default: 'Fleek Discord Forum',
    template: '%s | Fleek Discord Forum',
  },
  description: 'The web version of the Fleek Discord server',
  alternates: {
    canonical: getBaseUrl(),
  },
  openGraph: {
    title: {
      default: 'Fleek Discord Forum',
      template: '%s | Fleek Discord Forum',
    },
    description: 'The web version of the Fleek Discord server',
    type: 'website',
    url: getBaseUrl(),
    siteName: 'Fleek Discord Forum',
  },
  twitter: {
    card: 'summary',
    title: 'Fleek Discord Forum',
    description: 'The web version of the Fleek Discord server',
  },
}

type RootLayoutProps = { children: ReactNode }

const RootLayout = ({ children }: RootLayoutProps) => {
  return (
    <html lang="en" className={`${inter.className} dark`}>
      <body className="bg-neutral-50 dark:bg-neutral-900 text-slate-900 dark:text-white">
        <header className="border-b border-neutral-700">
          <div className="container max-w-7xl flex mx-auto px-4 py-6 justify-between items-center">
            <h1 aria-hidden="true" className="sr-only">
              Fleek Discord
            </h1>

            <a
              href="/"
              className="hover:opacity-75 text-white hover:no-underline transition-all duration-200"
            >
              <span className="flex flex-col xs:flex-row xs:space-x-2  xs:items-center">
                <LogoIcon className="w-[90px]" />
              </span>
            </a>

            <div className="flex space-x-5">
              <a
                href="https://discord.gg/fleek"
                target="_blank"
                rel="noopener"
                aria-label="Discord Server Invite"
                className="hover:opacity-75 text-white transition-all duration-200"
              >
                <DiscordIcon size={7} />
              </a>

              <a
                href="https://github.com/rafaelalmeidatk/nextjs-forum"
                target="_blank"
                rel="noopener"
                aria-label="Github Repository"
                className="hover:opacity-75 text-white transition-all duration-200"
              >
                <GitHubIcon size={7} />
              </a>
            </div>
          </div>
        </header>

        {children}

        <Analytics />
      </body>
    </html>
  )
}

export default RootLayout

================
File: apps/web/app/robots.ts
================
import { getBaseUrl } from '@/utils/urls'
import { MetadataRoute } from 'next'

export default function robots(): MetadataRoute.Robots {
  return {
    rules: {
      userAgent: '*',
      allow: '/',
    },
    sitemap: `${getBaseUrl()}/sitemap.xml`,
  }
}

================
File: apps/web/app/sitemap.ts
================
import { MetadataRoute } from 'next'
import { getBaseUrl } from '@/utils/urls'
import { db } from '@nextjs-forum/db/node'

// Update sitemap only once every 6 hours
export const revalidate = 21600

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const posts = await db
    .selectFrom('posts')
    .select(['snowflakeId', 'lastActiveAt'])
    .where('isIndexed', '=', true)
    .limit(50_000) // we will probably need to chunk the sitemap in the future
    .execute()

  return [
    {
      url: getBaseUrl(),
      changeFrequency: 'daily',
      priority: 1,
    },
    ...posts.map((p) => {
      return {
        url: `${getBaseUrl()}/post/${p.snowflakeId}`,
        changeFrequency: 'weekly',
        priority: 0.9,
        lastModified: p.lastActiveAt,
      } satisfies MetadataRoute.Sitemap[0]
    }),
  ]
}

================
File: apps/web/components/icons/arrow-down.tsx
================
import { IconProps, IconSvg } from './base'

export const ArrowDownIcon = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={1.5}
    stroke="currentColor"
    {...props}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M19.5 13.5L12 21m0 0l-7.5-7.5M12 21V3"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/arrow-left.tsx
================
import { IconProps, IconSvg } from './base'

export const ArrowLeftIcon = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={1.5}
    stroke="currentColor"
    {...props}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/arrow-right.tsx
================
import { IconProps, IconSvg } from './base'

export const ArrowRightIcon = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={1.5}
    stroke="currentColor"
    {...props}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/base.tsx
================
import { ComponentProps } from 'react'
import { twMerge } from 'tailwind-merge'

export type IconProps = ComponentProps<'svg'> & {
  size?: keyof typeof sizes
}

const sizes = {
  3: 'w-3 h-3',
  4: 'w-4 h-4',
  5: 'w-5 h-5',
  6: 'w-6 h-6',
  7: 'w-7 h-7',
  8: 'w-8 h-8',
  14: 'w-14 h-14',
}

export const IconSvg = ({ size = 6, className, ...props }: IconProps) => {
  return (
    <svg
      className={twMerge(
        `${sizes[size]} inline-block shrink-0 text-current align-middle`,
        className,
      )}
      fill="none"
      {...props}
    />
  )
}

================
File: apps/web/components/icons/calender-plus.tsx
================
import { IconProps, IconSvg } from './base'
export const CalendarPlusIcon = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={2}
    stroke="currentColor"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M8 2v4" />
    <path d="M16 2v4" />
    <path d="M21 13V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8" />
    <path d="M3 10h18" />
    <path d="M16 19h6" />
    <path d="M19 16v6" />
  </IconSvg>
)

================
File: apps/web/components/icons/check-circle-solid.tsx
================
import { IconProps, IconSvg } from './base'

export const CheckCircleSolidIcon = (props: IconProps) => (
  <IconSvg viewBox="0 0 24 24" fill="currentColor" {...props}>
    <path
      fillRule="evenodd"
      d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z"
      clipRule="evenodd"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/discord.tsx
================
import { IconProps, IconSvg } from './base'

export const DiscordIcon = (props: IconProps) => (
  <IconSvg viewBox="0 0 127 96" {...props}>
    <path
      fill="currentColor"
      d="M107.7,8.07A105.15,105.15,0,0,0,81.47,0a72.06,72.06,0,0,0-3.36,6.83A97.68,97.68,0,0,0,49,6.83,72.37,72.37,0,0,0,45.64,0,105.89,105.89,0,0,0,19.39,8.09C2.79,32.65-1.71,56.6.54,80.21h0A105.73,105.73,0,0,0,32.71,96.36,77.7,77.7,0,0,0,39.6,85.25a68.42,68.42,0,0,1-10.85-5.18c.91-.66,1.8-1.34,2.66-2a75.57,75.57,0,0,0,64.32,0c.87.71,1.76,1.39,2.66,2a68.68,68.68,0,0,1-10.87,5.19,77,77,0,0,0,6.89,11.1A105.25,105.25,0,0,0,126.6,80.22h0C129.24,52.84,122.09,29.11,107.7,8.07ZM42.45,65.69C36.18,65.69,31,60,31,53s5-12.74,11.43-12.74S54,46,53.89,53,48.84,65.69,42.45,65.69Zm42.24,0C78.41,65.69,73.25,60,73.25,53s5-12.74,11.44-12.74S96.23,46,96.12,53,91.08,65.69,84.69,65.69Z"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/github.tsx
================
import { IconProps, IconSvg } from './base'

export const GitHubIcon = (props: IconProps) => (
  <IconSvg viewBox="0 0 16 16" {...props}>
    <path
      fill="currentColor"
      d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/heart.tsx
================
import { IconProps, IconSvg } from './base'

export const HeartIcon = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={2}
    stroke="currentColor"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" />
  </IconSvg>
)

================
File: apps/web/components/icons/inbox.tsx
================
import { IconProps, IconSvg } from './base'

export const Inbox = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={1.5}
    stroke="currentColor"
    {...props}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M2.25 13.5h3.86a2.25 2.25 0 012.012 1.244l.256.512a2.25 2.25 0 002.013 1.244h3.218a2.25 2.25 0 002.013-1.244l.256-.512a2.25 2.25 0 012.013-1.244h3.859m-19.5.338V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18v-4.162c0-.224-.034-.447-.1-.661L19.24 5.338a2.25 2.25 0 00-2.15-1.588H6.911a2.25 2.25 0 00-2.15 1.588L2.35 13.177a2.25 2.25 0 00-.1.661z"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/incognito.tsx
================
import { IconProps, IconSvg } from './base'

export const IncognitoIcon = (props: IconProps) => (
  <IconSvg viewBox="0 0 16 16" {...props}>
    <path
      fill="currentColor"
      fillRule="evenodd"
      d="m4.736 1.968-.892 3.269-.014.058C2.113 5.568 1 6.006 1 6.5 1 7.328 4.134 8 8 8s7-.672 7-1.5c0-.494-1.113-.932-2.83-1.205a1.032 1.032 0 0 0-.014-.058l-.892-3.27c-.146-.533-.698-.849-1.239-.734C9.411 1.363 8.62 1.5 8 1.5c-.62 0-1.411-.136-2.025-.267-.541-.115-1.093.2-1.239.735Zm.015 3.867a.25.25 0 0 1 .274-.224c.9.092 1.91.143 2.975.143a29.58 29.58 0 0 0 2.975-.143.25.25 0 0 1 .05.498c-.918.093-1.944.145-3.025.145s-2.107-.052-3.025-.145a.25.25 0 0 1-.224-.274ZM3.5 10h2a.5.5 0 0 1 .5.5v1a1.5 1.5 0 0 1-3 0v-1a.5.5 0 0 1 .5-.5Zm-1.5.5c0-.175.03-.344.085-.5H2a.5.5 0 0 1 0-1h3.5a1.5 1.5 0 0 1 1.488 1.312 3.5 3.5 0 0 1 2.024 0A1.5 1.5 0 0 1 10.5 9H14a.5.5 0 0 1 0 1h-.085c.055.156.085.325.085.5v1a2.5 2.5 0 0 1-5 0v-.14l-.21-.07a2.5 2.5 0 0 0-1.58 0l-.21.07v.14a2.5 2.5 0 0 1-5 0v-1Zm8.5-.5h2a.5.5 0 0 1 .5.5v1a1.5 1.5 0 0 1-3 0v-1a.5.5 0 0 1 .5-.5Z"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/medal.tsx
================
import { IconProps, IconSvg } from './base'

export const MedalIcon = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={2}
    stroke="currentColor"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M7.21 15L2.66 7.14a2 2 0 0 1 .13-2.2L4.4 2.8A2 2 0 0 1 6 2h12a2 2 0 0 1 1.6.8l1.6 2.14a2 2 0 0 1 .14 2.2L16.79 15" />
    <path d="M11 12L5.12 2.2" />
    <path d="m13 12 5.88-9.8" />
    <path d="M8 7h8" />
    <circle cx="12" cy="17" r="5" />
    <path d="M12 18v-2h-.5" />
  </IconSvg>
)

================
File: apps/web/components/icons/next.tsx
================
import { IconProps, IconSvg } from './base'

export const LogoIcon = (props: IconProps) => (
  <IconSvg aria-label="Logo" role="img" viewBox="0 0 320 124" {...props}>
    <path
      d="M57.1018 43.8831L36.3312 75.5416L52.1457 72.1689C52.4578 72.6851 52.7699 73.2014 53.082 73.7177L3.71492 134.07H1.92383L22.2263 94.8709L7.30729 98.05C6.82899 97.3469 6.78828 97.296 6.30997 96.5929L26.4394 65.4948L11.3169 68.7147C10.8386 67.9504 10.8488 67.9505 10.3705 67.1761L59.707 6.85474H61.5184L41.4907 45.5439L56.1044 42.426C56.5929 43.129 56.6235 43.18 57.1018 43.8831Z"
      fill="currentColor"
    />
    <path
      d="M122.891 111.529L139.838 31.553H154.411L137.463 111.529H122.891Z"
      fill="currentColor"
    />
    <path
      d="M154.645 88.5093C154.645 70.2444 170.189 54.6814 189.079 54.6814C207.214 54.6814 218.008 70.0282 212.179 88.8335H169.001C169.541 95.9665 174.506 100.073 181.415 100.073C187.892 100.073 193.397 97.1554 197.175 92.292L208.725 97.6958C203.112 106.018 192.533 112.61 180.659 112.61C165.439 112.61 154.645 103.208 154.645 88.5093ZM171.268 77.7016H199.334C198.902 72.0817 194.368 67.2182 187.676 67.2182C181.091 67.2182 174.614 71.2171 171.268 77.7016Z"
      fill="currentColor"
    />
    <path
      d="M221.844 88.5093C221.844 70.2444 237.388 54.6814 256.278 54.6814C274.413 54.6814 285.207 70.0282 279.378 88.8335H236.2C236.74 95.9665 241.706 100.073 248.614 100.073C255.091 100.073 260.596 97.1554 264.374 92.292L275.924 97.6958C270.311 106.018 259.732 112.61 247.858 112.61C232.638 112.61 221.844 103.208 221.844 88.5093ZM238.467 77.7016H266.533C266.101 72.0817 261.567 67.2182 254.875 67.2182C248.29 67.2182 241.814 71.2171 238.467 77.7016Z"
      fill="currentColor"
    />
    <path
      d="M304.028 97.9118L301.114 111.529H286.541L303.488 31.553H318.061L308.454 76.4046L331.122 55.7621H351.2L324.214 79.8631L342.996 111.529H326.157L313.203 89.698L304.028 97.9118Z"
      fill="currentColor"
    />
    <path
      d="M83.2605 111.529L92.3278 68.6231H81.1016L83.9081 55.7621H95.1344L95.6741 53.1682C98.8045 37.6052 106.253 31.553 122.66 31.553H129.245L126.438 44.4141H119.962C113.917 44.4141 111.65 46.3594 110.355 52.3036L109.707 55.7621H124.064L121.365 68.6231H106.9L97.833 111.529H83.2605Z"
      fill="currentColor"
    />
  </IconSvg>
)

================
File: apps/web/components/icons/shield-check.tsx
================
import { IconProps, IconSvg } from './base'

export const ShieldCheckIcon = (props: IconProps) => (
  <IconSvg
    viewBox="0 0 24 24"
    fill="none"
    strokeWidth={1.5}
    stroke="currentColor"
    {...props}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M9 12.75L11.25 15 15 9.75m-3-7.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285z"
    />
  </IconSvg>
)

================
File: apps/web/components/layout-with-sidebar.tsx
================
import { ReactNode } from 'react'
import { twMerge } from 'tailwind-merge'
import { Sidebar } from '@/components/sidebar'

type LayoutWithSidebarProps = {
  className?: string
  children: ReactNode
}

export const LayoutWithSidebar = ({
  className,
  children,
}: LayoutWithSidebarProps) => {
  return (
    <div
      className={twMerge('container max-w-7xl mx-auto px-4 py-8', className)}
    >
      <main className="flex space-x-8">
        <section className="flex-1 w-full">{children}</section>
        <div className="hidden lg:block">
          <Sidebar />
        </div>
      </main>
    </div>
  )
}

================
File: apps/web/components/local-time.tsx
================
'use client'

import { useEffect, useState } from 'react'
import { buildPostTimeValues } from '@/utils/datetime'

type LocalTime = {
  text: string
  shortText: string
}

function useLocalTime(dateStr: string) {
  const [localTime, setLocalTime] = useState<LocalTime | null>(null)

  useEffect(() => {
    const date = new Date(dateStr)
    setLocalTime(buildPostTimeValues(date))
  }, [dateStr])

  return localTime
}

export const DisplayLocalTime = ({
  short,
  dateStr,
}: {
  short?: boolean
  dateStr: string
}) => {
  const localTime = useLocalTime(dateStr)
  if (!localTime) return <span className="invisible">{dateStr}</span>
  return (
    <span className="visible">
      {short ? localTime.shortText : localTime.text}
    </span>
  )
}

================
File: apps/web/components/message-content.tsx
================
import { parseDiscordMessage } from '@/utils/discord-markdown'
import { isVideoLink } from '@/utils/video'

export type Attachment = {
  id: string
  url: string
  name: string
  contentType: string
}

type MessageContentProps = {
  content: string
  attachments: Attachment[]
}

export const MessageContent = async ({
  content,
  attachments,
}: MessageContentProps) => {
  const htmlContent = await parseDiscordMessage(content)

  return (
    <>
      <div
        className="opacity-90 break-words"
        dangerouslySetInnerHTML={{ __html: htmlContent }}
      />

      <div className="mt-0.5 w-full max-w-[550px] space-y-1">
        {attachments.map((attachment) => (
          <div
            key={attachment.id}
            className="flex max-h-[350px] rounded-lg overflow-hidden"
          >
            {isVideoLink(attachment.url) ? (
              <video
                src={attachment.url}
                className="max-w-full h-auto object-cover"
                controls
              ></video>
            ) : (
              <img
                src={attachment.url}
                alt="Image"
                className="max-w-full h-auto object-cover"
              />
            )}
          </div>
        ))}
      </div>
    </>
  )
}

================
File: apps/web/components/message-group.tsx
================
import { ReactNode } from 'react'
import { twMerge } from 'tailwind-merge'
import { CheckCircleSolidIcon } from '@/components/icons/check-circle-solid'

type MessageGroupProps = { isAnswer: boolean; children: ReactNode }

export const MessageGroup = ({ isAnswer, children }: MessageGroupProps) => {
  return (
    <div>
      <div
        className={twMerge(
          'px-2 py-2 sm:px-3 sm:py-3 border border-neutral-800 rounded space-y-0.5',
          isAnswer && 'border-green-600 border-2',
        )}
      >
        {children}
      </div>
      {isAnswer && (
        <div className="flex items-center space-x-1 text-green-400 font-semibold py-1">
          <CheckCircleSolidIcon />
          <span>Answer</span>
        </div>
      )}
    </div>
  )
}

================
File: apps/web/components/message.tsx
================
import { buildPostTimeValues } from '@/utils/datetime'
import { DisplayLocalTime } from './local-time'
import 'highlight.js/styles/github-dark-dimmed.css'
import { Attachment, MessageContent } from './message-content'
import { IncognitoIcon } from './icons/incognito'
import { ShieldCheckIcon } from './icons/shield-check'
import Link from 'next/link'

type MessageProps = {
  snowflakeId: string
  content: string
  isFirstRow: boolean
  author: {
    username: string
    avatarUrl: string
    isPublic: boolean
    isOP: boolean
    isModerator: boolean
    userID: string
  }
  createdAt: Date
  attachments: Attachment[]
}

export const Message = ({
  snowflakeId,
  content,
  isFirstRow,
  author,
  createdAt,
  attachments,
}: MessageProps) => {
  const createdAtTimes = buildPostTimeValues(createdAt)

  return (
    <div id={`message-${snowflakeId}`} className="group ">
      <div className="flex flex-row items-start pointer-events-none [&>*]:pointer-events-auto">
        <div className="flex justify-start items-start w-[50px] sm:w-[60px] shrink-0">
          {isFirstRow ? (
            <img
              src={author.avatarUrl}
              alt="Avatar"
              className="w-10 h-10 rounded-full"
            />
          ) : (
            <time
              className="hidden self-center text-center group-hover:flex w-full items-center text-xs opacity-70"
              dateTime={createdAtTimes.iso}
              title={createdAtTimes.tooltip}
            >
              <DisplayLocalTime short dateStr={createdAt.toISOString()} />
            </time>
          )}
        </div>

        <div className="flex-1 w-0">
          {isFirstRow && (
            <div className="flex items-center space-x-2">
              <div className="font-semibold whitespace-nowrap overflow-hidden text-ellipsis">
                {author.isPublic ? (
                  <Link
                    className=" text-white opacity-90"
                    href={`/user/${author.userID}`}
                  >
                    {author.username}
                  </Link>
                ) : (
                  <span className="opacity-50">{author.username}</span>
                )}

                {!author.isPublic && (
                  <i title="User's profile isn't public">
                    <IncognitoIcon className="pl-2" />
                  </i>
                )}
                {author.isModerator && (
                  <i title="User is a moderator">
                    <ShieldCheckIcon className="pl-1" />
                  </i>
                )}
                {author.isOP && (
                  <span className="ml-2 px-1 py-0.5 text-xs text-neutral-900 bg-neutral-300 rounded-full select-none">
                    OP
                  </span>
                )}
              </div>
              <time
                className="mt-[1px] text-xs opacity-70"
                dateTime={createdAtTimes.iso}
                title={createdAtTimes.tooltip}
              >
                <DisplayLocalTime dateStr={createdAt.toISOString()} />
              </time>
            </div>
          )}

          <MessageContent content={content} attachments={attachments} />
        </div>
      </div>
    </div>
  )
}

================
File: apps/web/components/most-helpful.tsx
================
import { db } from '@nextjs-forum/db/node'
import { CheckCircleSolidIcon } from '@/components/icons/check-circle-solid'
import Link from 'next/link'

const getMostHelpfulUsers = async () => {
  return db
    .selectFrom('users')
    .select([
      'id',
      'username',
      'avatarUrl',
      'answersCount',
      'isPublic',
      'snowflakeId as userID',
    ])
    .orderBy('answersCount', 'desc')
    .orderBy('id', 'desc')
    .limit(15)
    .execute()
}

export const MostHelpful = async () => {
  const users = await getMostHelpfulUsers()

  if (users.length === 0) return null

  return (
    <>
      <div className="text-lg font-semibold">Most Helpful</div>

      <div className="mt-2 grid grid-cols-1 divide-y divide-neutral-800">
        {users.map((user) => (
          <div key={user.id} className="flex justify-between py-2">
            <div className="flex space-x-2 items-center">
              <img
                src={user.avatarUrl}
                alt="Avatar"
                className="w-4 h-4 rounded-full"
              />
              {user.isPublic ? (
                <Link
                  className="opacity-90 text-white"
                  href={`/user/${user.userID}`}
                >
                  {user.username}
                </Link>
              ) : (
                <div className="opacity-50">{user.username}</div>
              )}
            </div>
            <div className="flex items-center space-x-1 opacity-90">
              <CheckCircleSolidIcon size={5} />
              <span className="text-sm ">{user.answersCount}</span>
            </div>
          </div>
        ))}
      </div>
    </>
  )
}

================
File: apps/web/components/pagination-link.tsx
================
import Link from 'next/link'
import { ReactNode } from 'react'

type PaginationLinkProps = {
  iconLeft?: ReactNode
  iconRight?: ReactNode
  href: string
  children: ReactNode
}

export const PaginationLink = ({
  href,
  iconLeft,
  iconRight,
  children,
}: PaginationLinkProps) => {
  return (
    <Link
      href={href}
      className="px-3 py-1.5 border border-neutral-700 rounded-lg text-neutral-300 hover:text-neutral-100"
    >
      <span className="flex items-center space-x-1 opacity-90">
        {iconLeft}
        <span className="text-sm">{children}</span>
        {iconRight}
      </span>
    </Link>
  )
}

================
File: apps/web/components/post.tsx
================
import Link from 'next/link'
import plur from 'plur'
import { buildPostTimeValues } from '@/utils/datetime'

type PostProps = {
  id: string
  title: string
  messagesCount: number
  createdAt: Date
  hasAnswer: boolean
  author: {
    username: string
    avatar: string
  }
}

export const Post = ({
  id,
  title,
  messagesCount,
  createdAt,
  hasAnswer,
  author,
}: PostProps) => {
  const createdAtTimes = buildPostTimeValues(createdAt)
  const borderColor = hasAnswer ? 'border-green-700' : 'border-neutral-700'

  return (
    <Link href={`/post/${id}`} className="block text-white no-underline">
      <div
        className={`px-4 py-3 border bg-neutral-800 ${borderColor} rounded hover:opacity-90`}
      >
        <p className="text-white inline-block pr-2 text-lg font-semibold">
          {title}
        </p>

        <div className="mt-2 flex items-center space-x-2">
          <img
            src={author.avatar}
            alt={`${author.username}'s avatar`}
            className="rounded-full w-5 h-5"
          />
          <div className="text-sm opacity-90 no-underline">
            {author.username} asked on{' '}
            <time dateTime={createdAtTimes.iso} title={createdAtTimes.tooltip}>
              {createdAtTimes.text}
            </time>{' '}
            ¬∑ {messagesCount} {plur('Message', messagesCount)}
            {hasAnswer && (
              <span>
                {' '}
                ¬∑ <span className="font-semibold text-green-500">Answered</span>
              </span>
            )}
          </div>
        </div>
      </div>
    </Link>
  )
}

================
File: apps/web/components/posts-list.tsx
================
import { db, sql } from '@nextjs-forum/db/node'
import { ArrowLeftIcon } from '@/components/icons/arrow-left'
import { ArrowRightIcon } from '@/components/icons/arrow-right'
import { PaginationLink } from '@/components/pagination-link'
import { Post } from '@/components/post'
import { Inbox } from './icons/inbox'
import { Balancer } from 'react-wrap-balancer'

const POSTS_BY_PAGE = 20

const getPostsByPage = async (pageNumber: number) => {
  const limit = POSTS_BY_PAGE
  const offset = (pageNumber - 1) * limit

  return await db
    .selectFrom('posts')
    .innerJoin('users', 'users.snowflakeId', 'posts.userId')
    .leftJoin('messages', 'messages.snowflakeId', 'posts.answerId')
    .select([
      'posts.id',
      'posts.snowflakeId',
      'posts.title',
      'posts.createdAt',
      'users.username',
      'users.avatarUrl as userAvatar',
      sql<boolean>`messages.id is not null`.as('hasAnswer'),
      (eb) =>
        eb
          .selectFrom('messages')
          .select(eb.fn.countAll<string>().as('count'))
          .where('messages.postId', '=', eb.ref('posts.snowflakeId'))
          .where('messages.snowflakeId', '!=', eb.ref('posts.snowflakeId'))
          .as('messagesCount'),
    ])
    .where('isIndexed', '=', true)
    .orderBy('createdAt', 'desc')
    // Add one more result so we can know if there's a next page, not the
    // prettiest solution but it works great
    .limit(limit + 1)
    .offset(offset)
    .execute()
}

type PostsListProps = {
  page: number
}

export const PostsList = async ({ page }: PostsListProps) => {
  const posts = await getPostsByPage(page)

  if (posts.length === 0) {
    return (
      <div className="flex flex-col space-y-2 items-center justify-center">
        <Inbox size={14} className="opacity-75" />
        <div className="text-xl text-center w-full opacity-80">
          <Balancer>
            There are no posts indexed yet! Try checking again later
          </Balancer>
        </div>
      </div>
    )
  }

  const postsToRender = posts.slice(0, POSTS_BY_PAGE)
  const hasPreviousPage = page > 1
  const hasNextPage = posts.length > POSTS_BY_PAGE

  return (
    <>
      <div className="space-y-2">
        {postsToRender.map((post) => (
          <Post
            key={post.id.toString()}
            id={post.snowflakeId}
            title={post.title}
            createdAt={post.createdAt}
            messagesCount={parseInt(post.messagesCount ?? '0', 10)}
            hasAnswer={post.hasAnswer}
            author={{ avatar: post.userAvatar, username: post.username }}
          />
        ))}
      </div>
      <div className="mt-4 flex space-x-4 justify-center">
        {hasPreviousPage && (
          <PaginationLink
            href={`/page/${page - 1}`}
            iconLeft={<ArrowLeftIcon size={4} />}
          >
            Previous
          </PaginationLink>
        )}
        {hasNextPage && (
          <PaginationLink
            href={`/page/${page + 1}`}
            iconRight={<ArrowRightIcon size={4} />}
          >
            Next
          </PaginationLink>
        )}
      </div>
    </>
  )
}

================
File: apps/web/components/sidebar.tsx
================
import { MostHelpful } from '@/components/most-helpful'

export const Sidebar = () => {
  return (
    <aside className="w-[300px]">
      <MostHelpful />
    </aside>
  )
}

================
File: apps/web/pages/api/revalidate-home.ts
================
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' })
  }

  const secret = req.headers.authorization?.split(' ')[1]
  if (secret !== process.env.REVALIDATE_SECRET) {
    return res.status(401).json({ message: 'Invalid token' })
  }

  try {
    await res.revalidate('/')
    res.json({ revalidated: true })
  } catch (err) {
    res.status(500).json({ error: 'Error revalidating' })
  }
}

================
File: apps/web/pages/api/revalidate-post.ts
================
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' })
  }

  const secret = req.headers.authorization?.split(' ')[1]
  if (secret !== process.env.REVALIDATE_SECRET) {
    return res.status(401).json({ message: 'Invalid token' })
  }

  const { postId } = req.body
  if (!postId) {
    return res.status(400).json({ message: 'Missing the post ID' })
  }

  try {
    await Promise.all([res.revalidate('/'), res.revalidate(`/post/${postId}`)])
    res.json({ revalidated: true })
  } catch (err) {
    res.status(500).json({ error: 'Error revalidating' })
  }
}

================
File: apps/web/utils/datetime.ts
================
import { DateTime } from '@/utils/luxon'

export const buildPostTimeValues = (createdAt: Date) => {
  const datetime = DateTime.fromJSDate(createdAt)
  const text = datetime.setLocale('en-GB').toLocaleString({
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
  }) // 17 Sep 2023 at 15:20
  const shortText = datetime.toLocaleString({
    hour: 'numeric',
    minute: 'numeric',
  }) // 15:20
  const tooltip = datetime.setLocale('en-GB').toLocaleString({
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric',
    timeZoneName: 'short',
  }) // 17 September 2023 at 15:20:38 GMT+7
  const iso = datetime.toISO() // 2023-09-17T15:20:38.000+07:00

  return { text, shortText, tooltip, iso }
}

export const largerDate = (...dates: Date[]) => {
  return dates.reduce((a, b) => (a > b ? a : b))
}

================
File: apps/web/utils/discord-markdown.ts
================
import { toHTML } from 'discord-markdown'
import { load } from 'cheerio'
import { db } from '@nextjs-forum/db/node'
import { getCanonicalPostUrl } from './urls'
import { sanitizeText } from 'simple-markdown'
import { cache } from 'react'
import { unstable_cache } from 'next/cache'

interface UserCache {
  snowflakeId: string
  username: string
}

interface ChannelCache {
  snowflakeId: string
  name: string
}

interface PostCache {
  snowflakeId: string
  title: string
}

const fetchUser = cache((userId: string) => {
  return db
    .selectFrom('users')
    .select(['snowflakeId', 'username'])
    .where('snowflakeId', '=', userId)
    .executeTakeFirst()
})

const fetchChannel = cache((channelId: string) => {
  return db
    .selectFrom('channels')
    .select(['snowflakeId', 'name'])
    .where('snowflakeId', '=', channelId)
    .executeTakeFirst()
})

const fetchPost = cache((postId: string) => {
  return db
    .selectFrom('posts')
    .select(['snowflakeId', 'title'])
    .where('snowflakeId', '=', postId)
    .executeTakeFirst()
})

const channelLinkRegex =
  /https:\/\/discord\.com\/channels\/(?<guild>\d+)\/(?<channel>\d+)(\/(?<message>\d+))?/g
const userMention = /<@!?(?<user>\d+)>/g
const channelMention = /<#(?<channel>\d+)>/g

export const extractMentions = cache((content: string) => {
  const postIds = new Set<string>(
    Array.from(
      content.matchAll(channelLinkRegex),
      (m) => m.groups?.channel ?? '',
    ),
  )
  const memberIds = new Set<string>(
    Array.from(content.matchAll(userMention), (m) => m.groups?.user ?? ''),
  )
  const channelIds = new Set<string>(
    Array.from(
      content.matchAll(channelMention),
      (m) => m.groups?.channel ?? '',
    ),
  )
  return { postIds, memberIds, channelIds }
})

export const fetchMentions = async (content: string) => {
  const { postIds, memberIds, channelIds } = extractMentions(content)

  // Fetch from db/cache
  const [posts, users, channels] = await Promise.all([
    Promise.all(Array.from(postIds).map(fetchPost)),
    Promise.all(Array.from(memberIds).map(fetchUser)),
    Promise.all(Array.from(channelIds).map(fetchChannel)),
  ])

  return { posts, users, channels }
}

export const parseDiscordMessage = async (
  content: string,
  justText = false,
) => {
  // Get mentions
  const { users, channels, posts } = await fetchMentions(content)

  // Replace internal links
  content = content.replace(
    channelLinkRegex,
    (match, guildId, channelId, _, messageId) => {
      const post = posts.find((p) => p?.snowflakeId === channelId)
      if (!post) return match
      return `${getCanonicalPostUrl(post.snowflakeId)}${
        messageId ? `#message-${messageId}` : ''
      }`
    },
  )

  // Parse the content
  const html = toHTML(content, {
    discordCallback: {
      user: (node) => {
        const user = users.find((u) => u?.snowflakeId === node.id)
        if (!user) return `<i>@Unknown User</i>`

        const userName = sanitizeText(user.username)
        return `@${userName}`
      },
      channel: (node) => {
        const channel = channels.find((c) => c?.snowflakeId === node.id)
        let channelName = channel && sanitizeText(channel.name)

        if (!channelName) {
          const post = posts.find((p) => p?.snowflakeId === node.id)
          if (!post) return `<i>#Unknown Channel</i>`
          channelName = post.title
        }
        return `#${channelName}`
      },
    },
  })

  // Fixing some of the HTML
  const $ = load(html)

  // Links
  $('a').attr('target', '_blank').attr('rel', 'noopener nofollow ugc')

  // Code blocks
  $('pre:has(code)').addClass('d-code-block')

  // Inline code
  $('code:not(pre *)').addClass('d-code-inline')

  if (justText) {
    return $('body').text() ?? ''
  }

  return $('body').html() ?? ''
}

================
File: apps/web/utils/group-messages.ts
================
import { randomUUID } from 'crypto'

type RequiredMessageFields = {
  id: string
  snowflakeId: string
  authorId: string
  createdAt: Date
}

type GroupedMessages<T> = Array<{
  id: string
  messages: T[]
}>

export const groupMessagesByUser = <T extends RequiredMessageFields>(
  messages: T[],
  answerId: string | null = null,
) => {
  return messages.reduce<GroupedMessages<T>>((acc, message) => {
    const lastGroup = acc[acc.length - 1]

    if (!lastGroup) {
      return [{ id: randomUUID(), messages: [message] }]
    }

    const addToNewGroup = () => {
      acc.push({ id: randomUUID(), messages: [message] })
      return acc
    }

    // Break the group if the previous message is from a different user
    const lastMessage = lastGroup.messages.at(-1)
    if (!lastMessage || lastMessage.authorId !== message.authorId) {
      return addToNewGroup()
    }

    const secondsFromLastMessage =
      (message.createdAt.getTime() - lastMessage.createdAt.getTime()) / 1000

    // Break the group if the previous message have a considerable difference of time
    if (secondsFromLastMessage > 60 * 5) {
      return addToNewGroup()
    }

    // Break the group if this or the previous message is the post answer (this will isolate it)
    if (
      answerId &&
      (message.snowflakeId === answerId || lastMessage.snowflakeId === answerId)
    ) {
      return addToNewGroup()
    }

    lastGroup.messages.push(message)
    return acc
  }, [])
}

================
File: apps/web/utils/luxon.ts
================
import { Settings } from 'luxon'

// Always fail on invalid dates to avoid silent errors and the returning types including `null`
Settings.throwOnInvalid = true

export * from 'luxon'

// See https://github.com/DefinitelyTyped/DefinitelyTyped/pull/64995
declare module 'luxon' {
  export interface TSSettings {
    throwOnInvalid: true
  }
}

================
File: apps/web/utils/truncate.ts
================
export const truncate = (str: string, length: number) => {
  return str.length > length ? str.substring(0, length) + '‚Ä¶' : str
}

================
File: apps/web/utils/urls.ts
================
export const getBaseUrl = () => {
  return process.env.NEXT_PUBLIC_BASE_URL ?? 'http://localhost:3000'
}

export const getCanonicalPostUrl = (postId: string) => {
  return `${getBaseUrl()}/post/${postId}`
}

export const getCanonicalUserUrl = (discordId: string) => {
  return `${getBaseUrl()}/user/${discordId}`
}

================
File: apps/web/utils/video.ts
================
export const isVideoLink = (link: string): boolean => {
  const videoExtensions = ['.mp4', '.avi', '.mov', '.flv', '.wmv']
  return videoExtensions.some((ext) => link.endsWith(ext))
}

================
File: apps/web/.eslintrc.js
================
module.exports = {
  root: true,
  extends: ['@nextjs-forum/custom'],
}

================
File: apps/web/next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference types="next/navigation-types/compat/navigation" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

================
File: apps/web/next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'cdn.discordapp.com',
      },
    ],
  },
  transpilePackages: ['ui'],
}

module.exports = nextConfig

================
File: apps/web/package.json
================
{
  "name": "@nextjs-forum/web",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@nextjs-forum/db": "workspace:*",
    "@vercel/analytics": "^1.2.2",
    "cheerio": "^1.0.0-rc.12",
    "discord-markdown": "^2.5.1",
    "highlight.js": "^11.8.0",
    "luxon": "^3.3.0",
    "next": "^14.1.4",
    "plur": "^5.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-wrap-balancer": "^1.0.0",
    "simple-markdown": "^0.7.3",
    "tailwind-merge": "^2.2.2"
  },
  "devDependencies": {
    "@nextjs-forum/eslint-config-custom": "workspace:*",
    "@nextjs-forum/tsconfig": "workspace:*",
    "@types/luxon": "^3.4.2",
    "@types/node": "^20.12.2",
    "@types/react": "18.2.73",
    "@types/react-dom": "^18.2.23",
    "autoprefixer": "^10.4.19",
    "eslint": "8.57.0",
    "postcss": "^8.4.38",
    "schema-dts": "^1.1.2",
    "tailwindcss": "^3.4.3",
    "typescript": "^5.4.3"
  }
}

================
File: apps/web/postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: apps/web/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {
      screens: {
        xs: '475px',
      },
    },
  },
  plugins: [],
}

================
File: apps/web/tsconfig.json
================
{
  "extends": "@nextjs-forum/tsconfig/nextjs.json",
  "compilerOptions": {
    "paths": {
      "@/*": ["./*"]
    },
    "strictNullChecks": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: packages/db/migrations/0-initial.ts
================
import { Kysely } from 'kysely'
import { SnowflakeDataType, uuidColumnBuilder } from '../migrations-utils.js'
export async function up(db: Kysely<any>): Promise<void> {
  // --- Users
  await db.schema
    .createTable('users')
    .addColumn('id', 'uuid', uuidColumnBuilder)
    .addColumn('snowflakeId', SnowflakeDataType, (col) =>
      col.notNull().unique(),
    )
    .addColumn('isPublic', 'boolean', (col) => col.notNull().defaultTo(false))
    .addColumn('username', 'text', (col) => col.notNull())
    .addColumn('discriminator', 'varchar(4)', (col) => col.notNull())
    .addColumn('avatarUrl', 'text', (col) => col.notNull())
    .execute()

  await db.schema
    .createIndex('users_snowflakeId_idx')
    .on('users')
    .column('snowflakeId')
    .execute()

  // -- Channels
  await db.schema
    .createTable('channels')
    .addColumn('id', 'uuid', uuidColumnBuilder)
    .addColumn('snowflakeId', SnowflakeDataType, (col) =>
      col.notNull().unique(),
    )
    .addColumn('name', 'text', (col) => col.notNull())
    .addColumn('type', 'int2', (col) => col.notNull())
    .addColumn('topic', 'text', (col) => col.notNull())
    .execute()

  // -- Posts
  await db.schema
    .createTable('posts')
    .addColumn('id', 'uuid', uuidColumnBuilder)
    .addColumn('snowflakeId', SnowflakeDataType, (col) =>
      col.notNull().unique(),
    )
    .addColumn('title', 'text', (col) => col.notNull())
    .addColumn('isLocked', 'boolean', (col) => col.notNull())
    .addColumn('createdAt', 'timestamptz', (col) => col.notNull())
    .addColumn('editedAt', 'timestamptz')
    .addColumn('userId', SnowflakeDataType)
    .addColumn('channelId', SnowflakeDataType)
    .addColumn('answerId', SnowflakeDataType)
    .execute()

  await db.schema
    .createIndex('posts_snowflakeId_idx')
    .on('posts')
    .column('snowflakeId')
    .execute()

  await db.schema
    .createIndex('posts_userId_idx')
    .on('posts')
    .column('userId')
    .execute()

  await db.schema
    .createIndex('posts_channelId_idx')
    .on('posts')
    .column('channelId')
    .execute()

  // -- Messages
  await db.schema
    .createTable('messages')
    .addColumn('id', 'uuid', uuidColumnBuilder)
    .addColumn('snowflakeId', SnowflakeDataType, (col) =>
      col.notNull().unique(),
    )
    .addColumn('content', 'text', (col) => col.notNull())
    .addColumn('createdAt', 'timestamptz', (col) => col.notNull())
    .addColumn('editedAt', 'timestamptz')
    .addColumn('userId', SnowflakeDataType, (col) => col.notNull())
    .addColumn('postId', SnowflakeDataType, (col) => col.notNull())
    .addColumn('replyToMessageId', SnowflakeDataType)
    .execute()

  await db.schema
    .createIndex('messages_snowflakeId_idx')
    .on('messages')
    .column('snowflakeId')
    .execute()

  await db.schema
    .createIndex('messages_userId_idx')
    .on('messages')
    .column('userId')
    .execute()

  await db.schema
    .createIndex('messages_postId_idx')
    .on('messages')
    .column('postId')
    .execute()

  await db.schema
    .createIndex('messages_replyToMessageId_idx')
    .on('messages')
    .column('replyToMessageId')
    .execute()

  // -- Attachments
  await db.schema
    .createTable('attachments')
    .addColumn('id', 'uuid', uuidColumnBuilder)
    .addColumn('snowflakeId', SnowflakeDataType, (col) =>
      col.notNull().unique(),
    )
    .addColumn('url', 'text', (col) => col.notNull())
    .addColumn('name', 'text', (col) => col.notNull())
    .addColumn('contentType', 'text')
    .addColumn('messageId', SnowflakeDataType, (col) => col.notNull())
    .execute()

  await db.schema
    .createIndex('attachments_snowflakeId_idx')
    .on('attachments')
    .column('snowflakeId')
    .execute()

  await db.schema
    .createIndex('attachments_messageId_idx')
    .on('attachments')
    .column('messageId')
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.dropTable('attachments').execute()
  await db.schema.dropTable('messages').execute()
  await db.schema.dropTable('posts').execute()
  await db.schema.dropTable('channels').execute()
  await db.schema.dropTable('users').execute()
}

================
File: packages/db/migrations/1-add-moderator.ts
================
import { Kysely } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .alterTable('users')
    .addColumn('isModerator', 'boolean', (col) =>
      col.notNull().defaultTo(false),
    )
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.alterTable('users').dropColumn('isModerator').execute()
}

================
File: packages/db/migrations/2-users-answer-count.ts
================
import { Kysely } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .alterTable('users')
    .addColumn('answersCount', 'integer', (col) => col.notNull().defaultTo(0))
    .execute()

  await db.schema
    .createIndex('users_answersCount_idx')
    .on('users')
    .column('answersCount')
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.alterTable('users').dropColumn('answersCount').execute()
}

================
File: packages/db/migrations/3-add-last-active-to-post.ts
================
import { Kysely, sql } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .alterTable('posts')
    .addColumn('lastActiveAt', 'timestamptz', (col) =>
      col.notNull().defaultTo(sql`now()`),
    )
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.alterTable('posts').dropColumn('lastActiveAt').execute()
}

================
File: packages/db/migrations/4-points-system.ts
================
import { Kysely } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .alterTable('users')
    .addColumn('points', 'integer', (col) => col.notNull().defaultTo(0))
    .execute()

  await db.schema
    .createIndex('users_points_idx')
    .on('users')
    .column('points')
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.alterTable('users').dropColumn('points').execute()
}

================
File: packages/db/migrations/5-posts-is-indexed-flag.ts
================
import { Kysely } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .alterTable('posts')
    .addColumn('isIndexed', 'boolean', (col) => col.notNull().defaultTo(true))
    .execute()

  await db.schema
    .createIndex('posts_isIndexed_idx')
    .on('posts')
    .column('isIndexed')
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.alterTable('posts').dropColumn('isIndexed').execute()
}

================
File: packages/db/migrations/6-create-profile-page.ts
================
import { Kysely } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .alterTable('users')
    .addColumn('joinedAt', 'timestamptz')
    .execute()

  await db.schema
    .createIndex('users_answersCount_desc_snowflakeId_desc_idx')
    .on('users')
    .columns(['answersCount desc', 'snowflakeId desc'])
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.alterTable('users').dropColumn('joinedAt').execute()

  await db.schema
    .dropIndex('users_answersCount_desc_snowflakeId_desc_idx')
    .execute()
}

================
File: packages/db/.eslintrc.cjs
================
module.exports = {
  root: true,
  extends: ['@nextjs-forum/custom'],
}

================
File: packages/db/load-env.ts
================
import dotenv from 'dotenv'

dotenv.config({ path: './.env', debug: true })

================
File: packages/db/migrate.ts
================
import './load-env.js'
import path from 'path'
import url from 'url'
import fs from 'fs/promises'
import { Migrator, FileMigrationProvider } from 'kysely'
import { db } from './node.js'

const op = process.env.MIGRATE_OP ?? 'latest'
const dirname = url.fileURLToPath(new URL('.', import.meta.url))

const migrator = new Migrator({
  db,
  provider: new FileMigrationProvider({
    fs,
    path,
    migrationFolder: path.join(dirname, './migrations'),
  }),
})

if (op === 'list') {
  const migrations = await migrator.getMigrations()
  for (const migration of migrations) {
    console.log(`${migration.name} - Executed at: ${migration.executedAt}`)
  }

  await db.destroy()
  process.exit(0)
}

const { error, results } = await (op === 'latest'
  ? migrator.migrateToLatest()
  : migrator.migrateDown())

results?.forEach((it) => {
  if (it.status === 'Success') {
    console.log(
      `[${it.direction}] migration "${it.migrationName}" was executed successfully`,
    )
  } else if (it.status === 'Error') {
    console.error(
      `[${it.direction}] failed to execute migration "${it.migrationName}"`,
    )
  }
})

if (error) {
  console.error('Failed to migrate:')
  console.error(error)
  process.exit(1)
}

await db.destroy()

================
File: packages/db/migrations-utils.ts
================
import { ColumnDefinitionBuilder, sql } from 'kysely'

// varchar(20) would probably be enough but I want to be extra sure this won't break
export const SnowflakeDataType = 'varchar(40)'

export const uuidColumnBuilder = (col: ColumnDefinitionBuilder) =>
  col.primaryKey().defaultTo(sql`gen_random_uuid()`)

================
File: packages/db/node.ts
================
import {
  Kysely,
  sql,
  PostgresDialect,
  SelectExpression,
  Transaction,
} from 'kysely'
import pg from 'pg'
import { DB } from './schema.js'

if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL is not defined')
}

const { Pool } = pg

export const db = new Kysely<DB>({
  dialect: new PostgresDialect({
    pool: new Pool({
      connectionString: process.env.DATABASE_URL,
    }),
  }),
})

export { sql } from 'kysely'

export type TransactionDB = Transaction<DB>
export type KyselyDB = Kysely<DB>

================
File: packages/db/package.json
================
{
  "name": "@nextjs-forum/db",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc --build",
    "migrate": "NODE_OPTIONS='--loader ts-node/esm' ts-node ./migrate.ts",
    "migrate:down": "MIGRATE_OP=down NODE_OPTIONS='--loader ts-node/esm' ts-node ./migrate.ts",
    "migrate:list": "MIGRATE_OP=list NODE_OPTIONS='--loader ts-node/esm' ts-node ./migrate.ts",
    "db-codegen": "kysely-codegen --dialect postgres --out-file ./schema.ts",
    "lint": "eslint ."
  },
  "exports": {
    "./node": {
      "import": "./build/node.js"
    },
    "./nextjs": {
      "import": "./build/nextjs.js"
    }
  },
  "dependencies": {
    "kysely": "^0.27.3",
    "kysely-planetscale": "^1.3.0",
    "pg": "^8.11.4"
  },
  "devDependencies": {
    "@nextjs-forum/tsconfig": "workspace:*",
    "@types/pg": "^8.11.4",
    "dotenv": "^16.4.5",
    "kysely-codegen": "^0.14.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.3"
  }
}

================
File: packages/db/schema.ts
================
import type { ColumnType } from 'kysely'

export type Generated<T> = T extends ColumnType<infer S, infer I, infer U>
  ? ColumnType<S, I | undefined, U>
  : ColumnType<T, T | undefined, T>

export type Timestamp = ColumnType<Date, Date | string, Date | string>

export interface Attachments {
  contentType: string | null
  id: Generated<string>
  messageId: string
  name: string
  snowflakeId: string
  url: string
}

export interface Channels {
  id: Generated<string>
  name: string
  snowflakeId: string
  topic: string
  type: number
}

export interface Messages {
  content: string
  createdAt: Timestamp
  editedAt: Timestamp | null
  id: Generated<string>
  postId: string
  replyToMessageId: string | null
  snowflakeId: string
  userId: string
}

export interface Posts {
  answerId: string | null
  channelId: string | null
  createdAt: Timestamp
  editedAt: Timestamp | null
  id: Generated<string>
  isIndexed: Generated<boolean>
  isLocked: boolean
  lastActiveAt: Generated<Timestamp>
  snowflakeId: string
  title: string
  userId: string | null
}

export interface Users {
  answersCount: Generated<number>
  avatarUrl: string
  discriminator: string
  id: Generated<string>
  isModerator: Generated<boolean>
  isPublic: Generated<boolean>
  points: Generated<number>
  snowflakeId: string
  username: string
  joinedAt: Date | undefined
}

export interface DB {
  attachments: Attachments
  channels: Channels
  messages: Messages
  posts: Posts
  users: Users
}

================
File: packages/db/tsconfig.json
================
{
  "extends": "@nextjs-forum/tsconfig/node.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "build"
  },
  "exclude": ["build"]
}

================
File: packages/eslint-config-custom/index.js
================
module.exports = {
  extends: ['next', 'turbo', 'prettier'],
  rules: {
    '@next/next/no-html-link-for-pages': 'off',
    '@next/next/no-img-element': 'off',
    'turbo/no-undeclared-env-vars': [
      'error',
      {
        allowList: ['MIGRATE_OP'],
      },
    ],
  },
}

================
File: packages/eslint-config-custom/package.json
================
{
  "name": "@nextjs-forum/eslint-config-custom",
  "version": "0.0.0",
  "main": "index.js",
  "license": "MIT",
  "dependencies": {
    "eslint": "^8.45.0",
    "eslint-config-next": "13.4.12",
    "eslint-config-prettier": "^8.8.0",
    "eslint-config-turbo": "1.10.9",
    "eslint-plugin-react": "7.33.0"
  },
  "devDependencies": {
    "typescript": "^5.1.6"
  },
  "publishConfig": {
    "access": "public"
  }
}

================
File: packages/tsconfig/base.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    "composite": false,
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "inlineSources": false,
    "isolatedModules": true,
    "moduleResolution": "node",
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "preserveWatchOutput": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["node_modules"]
}

================
File: packages/tsconfig/nextjs.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Next.js",
  "extends": "./base.json",
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "incremental": true,
    "esModuleInterop": true,
    "module": "esnext",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": ["src", "next-env.d.ts"],
  "exclude": ["node_modules"]
}

================
File: packages/tsconfig/node.json
================
{
  "extends": "./base.json",
  "compilerOptions": {
    "lib": ["es2023"],
    "module": "node16",
    "target": "es2022",
    "moduleResolution": "node16"
  }
}

================
File: packages/tsconfig/package.json
================
{
  "name": "@nextjs-forum/tsconfig",
  "version": "0.0.0",
  "private": true,
  "files": [
    "base.json",
    "node.json",
    "nextjs.json",
    "react-library.json"
  ]
}

================
File: packages/tsconfig/react-library.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "React Library",
  "extends": "./base.json",
  "compilerOptions": {
    "jsx": "react-jsx",
    "lib": ["ES2015"],
    "module": "ESNext",
    "target": "es6"
  }
}

================
File: .eslintrc.js
================
module.exports = {
  root: true,
  // This tells ESLint to load the config from the package `eslint-config-custom`
  extends: ['@nextjs-forum/custom'],
  settings: {
    next: {
      rootDir: ['apps/*/'],
    },
  },
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# next.js
.next/
out/
build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env.local
.env.development.local
.env.test.local
.env.production.local

# turbo
.turbo

# env files
.env

================
File: .prettierrc
================
{
  "singleQuote": true,
  "semi": false
}

================
File: docker-compose.yml
================
version: '3.9'

services:
  postgres:
    container_name: nextjsforum_postgres
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: nextjsforum
      POSTGRES_USER: nextjsuser
      POSTGRES_PASSWORD: nextjspassword
      PGDATA: /data/postgres
    ports:
      - 5432:5432
    volumes:
      - postgres:/data/postgres
    restart: unless-stopped

volumes:
  postgres:

================
File: LICENSE
================
MIT License

Copyright (c) 2023 Rafael Almeida

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "nextjs-forum",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "build:bot": "turbo run build --filter=bot...",
    "start": "turbo run start",
    "start:bot": "turbo run start --filter=bot",
    "dev": "turbo run dev",
    "lint": "turbo run lint",
    "migrate": "pnpm --filter=@nextjs-forum/db migrate",
    "register-commands": "pnpm --filter=@nextjs-forum/bot register-commands",
    "dev:register-commands": "pnpm --filter=@nextjs-forum/bot dev:register-commands",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "prepare": "husky install"
  },
  "devDependencies": {
    "@nextjs-forum/eslint-config-custom": "workspace:*",
    "husky": "^8.0.3",
    "lint-staged": "^15.1.0",
    "prettier": "^3.1.0",
    "turbo": "^1.11.2"
  },
  "engines": {
    "node": ">=18.0.0",
    "pnpm": ">=8.11.0"
  },
  "lint-staged": {
    "*.{js,ts,tsx,md,json}": "prettier --write"
  },
  "resolutions": {
    "@types/react": "18.2.15"
  },
  "packageManager": "pnpm@9.10.0"
}

================
File: pnpm-workspace.yaml
================
packages: 
  - "apps/*"
  - "packages/*"

================
File: README.md
================
<h1 align="center">
  <img src="https://camo.githubusercontent.com/f21f1fa29dfe5e1d0772b0efe2f43eca2f6dc14f2fede8d9cbef4a3a8210c91d/68747470733a2f2f6173736574732e76657263656c2e636f6d2f696d6167652f75706c6f61642f76313636323133303535392f6e6578746a732f49636f6e5f6c696768745f6261636b67726f756e642e706e67" alt="Next.js Logo" width="84">
  <br>
  Next.js Discord Forum
</h1>

<p align="center">The Fleek Discord server indexed in the web</p>

## Getting Started

This repo contains the code for both the Discord bot that index the posts and the front-end app

### Installing the dependencies

```sh
pnpm install
```

### Configuring the env vars

If you are developing locally, you need to create `.env` files in both the `apps/web` and `app/bot` folder. Refer to the table below for all the env vars in the project

#### Project: `apps/web`

| Name                   | Description                                                                                              | Required? |
| ---------------------- | -------------------------------------------------------------------------------------------------------- | --------- |
| `DATABASE_URL`         | The read-only connection string to connect to the DB, used to query the posts and messages               | ‚úîÔ∏è        |
| `REVALIDATE_SECRET`    | The secret that allows remote revalidations to the app cache. This var should also be set in the bot app | ‚úîÔ∏è        |
| `NEXT_PUBLIC_BASE_URL` | The URL where the app is hosted                                                                          | ‚ùå        |

#### Project: `apps/bot`

| Name                     | Description                                                                                                             | Required? |
| ------------------------ | ----------------------------------------------------------------------------------------------------------------------- | --------- |
| `DISCORD_BOT_TOKEN`      | The token for the bot. If you don't have a bot yet, go to the bot project section for more details on how to create one | ‚úîÔ∏è        |
| `DISCORD_CLIENT_ID`      | Client ID of the bot app                                                                                                | ‚úîÔ∏è        |
| `DEV_GUILD_ID`           | The ID of the Discord server to register dev commands with `pnpm dev:register-commands`                                 | ‚ùå        |
| `PUBLIC_PROFILE_ROLE_ID` | The ID of the role to make Discord profiles public in the database                                                      | ‚ùå        |
| `HELPER_ROLE_ID`         | The ID of the role that allows for selecting answer on behalf of owner                                                  | ‚ùå        |
| `MODERATOR_ROLE_ID`      | The ID of the role to set moderator status in the database (also can select answer)                                     | ‚ùå        |
| `REGULAR_MEMBER_ROLE_ID` | The ID of the role to add to users when they reach the points milestone                                                 | ‚ùå        |
| `INDEXABLE_CHANNEL_IDS`  | Comma-separated list of forum channels to index                                                                         | ‚úîÔ∏è        |
| `MOD_LOG_CHANNEL_ID`     | The ID of the channel to log things for mods                                                                            | ‚ùå        |
| `DATABASE_URL`           | The connection string to connect to the DB                                                                              | ‚úîÔ∏è        |
| `REVALIDATE_SECRET`      | The same secret from the `web` project                                                                                  | ‚úîÔ∏è        |
| `WEB_URL`                | The address of the web service, used to make the call to revalidate the cache                                           | ‚úîÔ∏è        |

#### Project: `packages/db` (only necessary if you plan to run migrations)

| Name           | Description                                                                 | Required? |
| -------------- | --------------------------------------------------------------------------- | --------- |
| `DATABASE_URL` | The admin connection string to connect to the DB, used to modify the schema | ‚úîÔ∏è        |

### Running the development projects

To run both the `web` and `bot` projects at the same time, use the following command:

```sh
pnpm dev
```

> **Note**: You don't need to run both projects always at the same time, they can work separately

## Creating your own bot instance

You will need your own bot to run the project locally, it is also recommended to create a new Discord server as a testing playground.

1. Go to https://discord.com/developers/applications and click on New Application
2. In the General Information page, copy the `APPLICATION ID`, this is the value of the `DISCORD_CLIENT_ID` env var
3. Go to the Bot page, click on Reset Token. Copy the new token and store it in the `DISCORD_BOT_TOKEN` env var. **DO NOT** share this token anywhere
4. In the "Privileged Gateway Intents" section, enable `SERVER MEMBERS INTENT` and `MESSAGE CONTENT INTENT`

To invite the bot to your own server, go to the OAuth2 > URL Generator page, select the `bot` scope and add the following permissions:

- Manage Roles
- Send Messages
- Send Messages in Threads
- Manage Message
- Manage Threads
- Embed Links
- Read Message History
- Add Reactions
- Use Slash Commands

Copy the Generated URL and open it in your browser

### Registering Discord commands

To use the context and slash commands you first need to register them in Discord. The easiest way to do that is by running this command:

```sh
pnpm dev:register-commands
```

Notice the `dev:` prefix in the command. Discord limits how many times you can register commands with their API, but by registering the command in a specific server you can do this as many times as you want. You need the `DEV_GUILD_ID` env var set to use this command

## Creating the database

This project uses PostgreSQL for the database, the easiest way to get it up and running is by using Docker. Start the database with this command:

```sh
docker compose up
```

And use this for the environment variable:

```sh
DATABASE_URL='postgresql://nextjsuser:nextjspassword@localhost:5432/nextjsforum'
```

If for some reason you want to start the database from scratch you can use the following command (this will erase all the data!):

```sh
docker compose down -v
```

### Running migrations

Once the database is running, add the previous `DATABASE_URL` variable to the `packages/db/.env` file and run this command:

```sh
pnpm migrate
```

================
File: turbo.json
================
{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": ["**/.env.*local"],
  "globalEnv": ["DATABASE_URL", "REVALIDATE_SECRET", "NEXT_PUBLIC_BASE_URL"],
  "pipeline": {
    "dev": { "cache": false },
    "start": { "cache": false },
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["build/**", ".next/**"]
    },
    "lint": {
      "outputs": []
    }
  }
}
